% =============================================================================
%  $RCSfile: language.tex,v $, $Revision: 1.4 $
%  $Date: 2003/04/06 04:23:11 $
%  $Author: keulsn $
%
%  Description:
%
%  Last-Ispelled-Revision: 1.1
%
% =============================================================================

%%%% Non-terminals
\nonterminal{\gqslargumentlist}{argument\_list}
\nonterminal{\gqslassignment}{assignment}
\nonterminal{\gqslcalculation}{calculation}
\nonterminal{\gqslcomplexstatement}{complex\_statement}
\nonterminal{\gqsldeclaration}{declaration}
\nonterminal{\gqsldeclarationpart}{declaration\_part}
\nonterminal{\gqsldigit}{digit}
\nonterminal{\gqsledgepredicate}{edge\_predicate}
\nonterminal{\gqsledgesetexpression}{edge\_set\_expression}
\nonterminal{\gqslexpression}{expression}
\nonterminal{\gqslidentifier}{identifier}
\nonterminal{\gqslintliteral}{int\_literal}
\nonterminal{\gqslletter}{letter}
\nonterminal{\gqslliteralexpression}{literal\_expression}
\nonterminal{\gqslnodepredicate}{node\_predicate}
\nonterminal{\gqslnodesetexpression}{node\_set\_expression}
\nonterminal{\gqslparameterlist}{parameter\_list}
\nonterminal{\gqslquery}{query}
\nonterminal{\gqslquerybody}{query\_body}
\nonterminal{\gqslquerycall}{query\_call}
\nonterminal{\gqslregexp}{regexp}
\nonterminal{\gqslregexpchar}{regexp\_char}
\nonterminal{\gqslscript}{script}
\nonterminal{\gqslscriptbody}{script\_body}
\nonterminal{\gqslscriptcall}{script\_call}
\nonterminal{\gqslselectionexpression}{selection\_expression}
\nonterminal{\gqslstatement}{statement}
\nonterminal{\gqslstringchar}{string\_char}
\nonterminal{\gqslstringliteral}{string\_literal}
\nonterminal{\gqslsubgraphexpression}{subgraph\_expression}
\nonterminal{\gqsltype}{type}
\nonterminal{\gqslvariableinspection}{variable\_inspection}

%%%% Tokens
\token{\tokaccept}{accept}
\token{\tokallnodes}{all\_nodes}
\token{\tokbased}{based}
\token{\tokbegin}{begin}
\token{\tokbegincomment}{//}
\token{\tokbeginrequote}{<}
\token{\tokbuild}{build}
\token{\tokclosebracket}{)}
\token{\tokcolon}{:}
\token{\tokcomma}{,}
\token{\tokdepth}{depth}
\token{\tokequal}{=}
\token{\tokedges}{edges}
\token{\tokedgeset}{edge\_set}
\token{\tokend}{end}
\token{\tokendrequote}{>}
\token{\tokfollow}{follow}
\token{\tokfrom}{from}
\token{\tokgraph}{graph}
\token{\tokintersect}{intersect}
\token{\tokinteger}{integer}
\token{\tokis}{is}
\token{\tokmake}{make}
\token{\tokminus}{-}
\token{\toknodes}{nodes}
\token{\toknodeset}{node\_set}
\token{\tokon}{on}
\token{\tokopenbracket}{(}
\token{\tokplus}{+}
\token{\tokquery}{query}
\token{\tokquote}{''}
\token{\tokreturn}{return}
\token{\tokrootnode}{root\_node}
\token{\tokscript}{script}
\token{\tokselect}{select}
\token{\tokselection}{selection}
\token{\toksemicolon}{;}
\token{\tokstring}{string}
\token{\toksubgraph}{subgraph}
\token{\tokto}{to}
\token{\tokuntil}{until}

\section{IML-Graphen}

Der Kunde stellt die Reflektion zur Verfügung. GIANT verwendet diese
Bibliothek, um auf IML-Graph Dateien zuzugreifen.

\subsection{IML-Programme}
\index{IML-Graph Datei!Inhalt}

In jeder IML-Graph Datei ist ein IML-Programm enthalten. Das IML-Programm
besteht aus
\begin{enumerate}
\item IML-Knoten
\item Attributen von IML-Knoten
\item nichts sonst.
\end{enumerate}

Es gibt in jedem IML-Programm einen besonderen IML-Knoten, der Wurzelknoten
genannt wird.

\subsubsection{Attribute von IML-Knoten}

Jeder IML-Knoten verfügt über eine Folge von Attributen.
Diese Folge definiert eine endliche Anzahl einzelner Attribute,
die der IML-Knoten besitzt sowie eine Reihenfolge dieser Attribute.
Weder die Folge von Attributen noch die in der Folge enthaltenen
Attribute eines IML-Knoten können sich während der Laufzeit von
GIANT verändern.

Jedes Attribut besitzt einen Attribut-Namen. Kein IML-Knoten besitzt
zwei verschiedene Attribute, die einen gleichen Namen besitzen.

Einige Attribute sind Verweise. Sie verweisen auf höchstens einen
IML-Knoten. Es werden unterschieden:
\begin{description}
\item[genutzte Verweise] Verweise, die auf genau einen
           IML-Knoten verweisen
\item[ungenutzte Verweise] Verweise, die nicht auf einen
           IML-Knoten verweisen
\end{description}

Jedes Attribut eines IML-Knoten gehört genau einer der folgenden Klassen an:
\begin{description}
\item[Einfache Attribute]: Haben einen bestimmten Wert.
           Mögliche Typen dieses Werts sind:
           \begin{enumerate}
           \item Source Location
                 \begin{itemize}
                 \item Zeilennummer
                 \item Spaltennummer
                 \item Filename
                 \item Pfadname
                 \end{itemize}
           \item Boolean
           \item Natural
           \item Folge von Strings
           \end{enumerate}
\item[Bezeichner-Attribut] Haben als Wert einen besonderen String
\item[Genutztes Verweis-Attribut] Ein genutzter Verweis
\item[Ungenutztes Verweis-Attribut] Ein ungenutzter Verweis
\item[Verweisfolgen-Attribut] Eine endliche, nicht leere Folge von
           genutzten Verweisen
\item[Verweismengen-Attribut] Eine endliche, nicht leere Menge
           von genutzten Verweisen
\end{description}



\subsection{IML-Graphen}

Jedes IML-Programm definiert einen zugehörigen IML-Graph.
Sprechweise: Das IML-Programm liegt dem IML-Graph zugrunde.
Ein IML-Graph ist ein gerichteter knoten- und kantenannotierter Graph mit
Schlingen und Mehrfachkanten. Er ist definiert durch die folgende
Vorschrift:

\begin{enumerate}
\item
Ein IML-Graph besitzt als Knotenmenge die Menge alle IML-Knoten des
zugrunde liegenden IML-Programms. Der IML-Graph besitzt keine
weiteren Knoten.
\item
Annotationen eines IML-Knoten sind alle Attribute des IML-Knoten.
\item
\label{language_edge_spec}
Eine Kante im IML-Graph heißt IML-Kante. Eine IML-Kante $e$ von einem
IML-Knoten $v$ zu einem IML-Knoten $w$ des selben IML-Graph existiert
genau dann, wenn eine der folgenden Bedingungen erfüllt ist:
   \begin{enumerate}
   \item $v$ besitzt ein Genutztes Verweis-Attribut, das auf $w$ verweist.
         $e$ besitzt als Annotation den Attribut-Namen des Genutzten
         Verweis-Attributs.
   \item $v$ besitzt ein Verweisfolgen-Attribut $f$. Ein genutzter Verweis
         aus $f$ verweist auf $w$. $e$ besitzt als Annotation den
         Attribut-Namen von $f$ sowie die Nummer innerhalb der Folge
         $f$ des genutzten Verweises auf $w$.
   \item $v$ besitzt ein Verweismengen-Attribut $m$. Ein genutzter Verweis
         aus $m$ verweist auf $w$. $e$ besitzt als Annotation den
         Attribut-Namen von $m$
   \end{enumerate}
\item
Falls eine IML-Kante $e$ existiert, so hat $e$ keine Annotationen,
außer den in Punkt \ref{language_edge_spec} genannten.
\end{enumerate}



\section{GQSL}

Die GIANT Query \& Skripting Language dient dazu, IML-Teilgraphen und
Selektionen aus einem IML-Graph anzufragen und auf diesen Aktionen
auszuführen.

Die Sprache lässt sich in zwei zentrale Konstrukte gliedern:
\begin{description}
\item[Queries] dienen der Anfrage eines Werts.
\item[Scripts] werden verwendet, um Aktionen auszuführen.
\end{description}

Als Aktion wird die Ausführung eines vordefinierten Scripts bezeichnet
(siehe Kapitel \ref{language_gqsl_predef_env}).
Aktionen können GIANT zu Reaktionen veranlassen, die für den Benutzer
direkt sichtbar sind und für seine Arbeit nützlich sein können
(z.B. Anzeigen eines IML-Teilgraphen in einem Anzeigefenster).


GQSL Queries können nicht direkt ausgeführt, sondern nur von GQSL Scripts
aufgerufen werden.
GQSL Scripts werden von einem GQSL Interpreter ausgeführt. 
Scripts können Queries aufrufen, um Daten zu gewinnen. Mit diesen Daten
sollen Aktionen nach den Wünschen des Benutzers konfiguriert werden.
Queries und Scripts können in Variablen Werte zwischenspeichern.


\subsection{GQSL Interpreter}

Ein GQSL Interpreter ist ein System, das GQSL Scripts ausführt, gemäß
der Sprachdefinition in Kapitel \ref{language_gqsl_spec}. Jeder GQSL
Interpreter muss die vordefinierte Sprachumgebung gemäß Kapitel
\ref{language_gqsl_predef_env} unterstützen.

\subsubsection{Kontext des Interpreters}

Der GQSL Interpreter kann im Kontext eines Anzeigefensters ausgeführt
werden. Ist dies der Fall, so sollen die ausgeführten GQSL Scripts und
GQSL Queries Zugriff auf das Anzeigefenster haben, ohne den Namen des
Anzeigefensters zu kennen.

Der Zugriff auf das Anzeigefenster in dessen Kontext der GQSL Interpreter
ausgeführt wird soll über spezielle vordefinierte Queries durchgeführt
werden.

\subsubsection{Verhalten im Fehlerfall}

Der GQSL Interpreter muss ein Script bzw. eine Query zurückweisen, falls eine
Forderung der Sprachdefinition von diesem Script bzw. dieser Query verletzt
wird. In diesem Fall muss der Interpreter dem Benutzer eine Fehlermeldung
anzeigen, die folgede Anforderungen erfüllt:
\begin{enumerate}
\item Der Benutzer wird informiert, dass der Text des Scripts bzw. der Query
fehlerhaft ist.
\item Dem Benutzer wird die Art des Fehlers präzise erläutert.
\item Dem Benutzer wird angezeigt an welcher Stelle in welchem Script bzw.
in welcher Query der Fehler erkannt wurde.
\end{enumerate}
Andernfalls startet der GQSL Interpreter die Ausführung.

Der GQSL Interpreter muss die Ausführung sofort
stoppen, sobald die erste \gqslexpression zu fehlerhaft ausgewertet wird
oder sobald ein \gqslstatement oder \gqslcomplexstatement fehlerhaft
ausgeführt wird. Diese Ereignisse werden als Fehler angesehen.
Der GQSL Interpreter
darf die Ausführung bereits nach einem früheren Ausführungsschritt abbrechen,
wenn sichergestellt ist, dass zu nach einem späteren Ausführungsschritt
einer der genannten Fälle eintreten wird.

Der GQSL Interpreter muss dem Benutzer unverzüglich eine
Meldung anzeigen, die folgende Anforderungen erfüllt:
\begin{enumerate}
\item Der Benutzer muss informiert werden, dass ein Fehler aufgetreten ist.
\item Dem Benutzer muss präzise und für ihn leicht verständlich erläutert
werden, welcher Fehler aufgetreten ist.
\item Dem Benutzer kann eine Möglichkeit aufgezeigt werden, wie er den
Fehler beseitigen kann um eine fehlerfreie Ausführung des selben Scripts zu
ermöglichen.
\end{enumerate}

Der GQSL Interpreter muss nach einem Fehler entweder alle seit Beginn
der Ausführung bereits ausgeführten Aktionen rückgängig machen, oder er
muss dem Benutzer anzeigen, welche Aktionen bereits durchgeführt wurden,
bevor der Fehler passierte. Anhand dieser Information soll es dem Benutzer
möglich sein, die Aktionen manuell rückgängig zu machen.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{GQSL Sprachdefinition}
\label{language_gqsl_spec}

Die Syntax von GQSL wird beschrieben in Anlehnung an die
Beschreibungsmethode des Ada Reference Manual. Siehe ARM Kapitel 1.1.4 für
Details.


%%%%%%%%%%%%%%%%%%%%
\subsubsection{White Space}

Leerzeichen, Tabulatoren, Zeilenumbrüche und Kommentare können als
Trennzeichen verwendet werden.

Kommentare werden durch \tokbegincomment eingeleitet und gehen immer
bis zum Zeilenende.


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Schlüsselwörter}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Bezeichner}

\begin{EBNF}
\item[\gqslidentifier] \gqslletter \{~\gqslletter | \gqsldigit~\}
\end{EBNF}

\begin{enumerate}
\item
\gqslletter steht für einen der Buchstaben a-z oder A-Z.
\item
\gqsldigit steht für eine der Ziffern 0-9.
\item
Der gesamte Text des \gqslidentifier darf nicht ein Schlüsselwort von GQSL
sein.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Literale}

\begin{EBNF}
\item[\gqslstringliteral] \tokquote \{ \gqslstringchar\} \tokquote
\end{EBNF}

Wobei \gqslstringchar für ein von \tokquote verschiedenes Zeichen steht.
Der Typ eines \gqslstringliteral ist \tokstring.

\begin{EBNF}
\item[\gqslintliteral] [ \tokplus|\tokminus ] \gqsldigit \{ \gqsldigit\}
\end{EBNF}

Der Typ eines \gqslintliteral ist \tokinteger

\begin{EBNF}
\item[\gqslregexp] \tokbeginrequote \{ \gqslregexpchar \} \tokendrequote
\end{EBNF}

Wobei \gqslregexpchar für ein von \tokbeginrequote und \tokendrequote
und von White Space verschiedenes Zeichen steht. \{ \gqslregexpchar \}
muss ein gültiger regulärer Ausdruck sein, nach der Definition des
Ada95-Pakets GNAT.Regpat.


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Typen}
\label{language_types}

Jede \gqslexpression und jede Variable hat in GQSL einen Typ, der ihren
Wertebereich bestimmt.

\begin{EBNF}
\item[\gqsltype] \tokinteger | \tokstring | \toknodeset | \tokedgeset
                 | \toksubgraph | \tokselection
\end{EBNF}

\begin{description}
\item[\tokinteger] Ganze Zahlen in einem implemetierungsabhängigen
Bereich $min .. max$ mit $min < -16.000$ und $max > +16.000$.
Ein GQSL-Interpreter muss den genauen Wertebereich dokumentieren.
\item[\tokstring] Zeichenkette beliebiger Länge
\item[\toknodeset] Endliche Menge von IML-Knoten
\item[\tokedgeset] Endliche Menge von IML-Kanten
\item[\toksubgraph] Endliche Menge von IML-Knoten zusammen mit endlicher
Menge von IML-Kanten. Für jede enthaltene IML-Kante $e$ mit Quellknoten $v$
und Zielknoten $w$ sind stets $v$ und $w$ ebenfalls in dem
\toksubgraph enthalten. Variablen dieses Typs können IML-Teilgraphen
speichern.
\item[\tokselection] Endliche Menge von IML-Knoten zusammen mit endlicher
Menge von IML-Kanten. Variablen dieses Typs können Selektionen speichern.
\end{description}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Variablen}
\label{language_variables}

Eine \gqslquery oder ein \gqslscript kann in ihrem/seinem
\gqsldeclarationpart Variablen deklarieren. Jede dieser Variablen hat einen
definierten Typ (siehe Kapitel \ref{language_types}).

\begin{EBNF}
\item[\gqsldeclarationpart] \{ \gqsldeclaration \toksemicolon \}
\item[\gqsldeclaration] \gqslidentifier \tokcolon \gqsltype
\end{EBNF}

\begin{enumerate}
\item Wird eine \gqslquery oder ein \gqslscript aufgerufen, so werden alle
Variablen des zugehörigen \gqsldeclarationpart erzeugt. 
\item Alle diese Variablen werden zerstört wenn die Ausführung der \gqslquery
bzw. des \gqslscript endet.
\item Zu jedem Zeitpunkt der Ausführung hat jede
dieser Variablen einen Wert innerhalb des Wertebereichs ihres Typs. Der Wert
ändert sich nur durch ein \gqslassignment an die Variable.
\item Jede \gqsldeclaration deklariert genau eine Variable, die über ihren
\gqslidentifier innerhalb des \gqslquerybody bzw. des \gqslscriptbody
verwendet wird. Sie ist vom Typ \gqsltype.
\item Keine zwei verschiedenen \gqsldeclaration dürfen den gleichen
\gqslidentifier innerhalb des selben \gqsldeclarationpart verwenden.
\item Keine \gqsldeclaration darf
den gleichen \gqslidentifier verwenden wie eine \gqsldeclaration innerhalb
einer \gqslparameterlist, deren Parameter im selben \gqslquerybody bzw.
\gqslscriptbody sichtbar sind (siehe Kapitel \ref{language_parameter}).
\item Zum Zeitpunkt der Erzeugung nimmt eine Variable ihren Initialwert an.
Der Initialwert einer Variable kann nicht spezifiziert werden. Es dürfen
keine Annahmen über den Initialwert getroffen werden.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Parameter}
\label{language_parameter}

Eine \gqslquery oder ein \gqslscript kann Parameter deklarieren.
Jeder dieser Parameter hat einen
definierten Typ (siehe Kapitel \ref{language_types}).

\begin{EBNF}
\item[\gqslparameterlist] \gqsldeclaration
                          \{ \toksemicolon \gqsldeclaration \}
\end{EBNF}

\begin{enumerate}
\item Wird eine \gqslquery oder ein \gqslscript aufgerufen, so werden alle
Parameter erzeugt und mit einem durch den Aufruf spezifizierten Initialwert
belegt.
\item Alle Parameter werden zerstört, wenn die Ausführung der \gqslquery
bzw. des \gqslscript endet.
\item Zu jedem Zeitpunkt der Ausführung hat jeder Parameter einen Wert
innerhalb des Wertebereichs seines Typs. Der Wert eines Parameters ändert
sich nur duch ein \gqslassignment an den Parameter.
\item Jede \gqsldeclaration deklariert genau einen Parameter, der über seinen
\gqslidentifier innerhalb des \gqslquerybody bzw. des \gqslscriptbody
verwendet wird.
\item Keine zwei verschiedenen \gqsldeclaration dürfen den gleichen
\gqslidentifier innerhalb der selben \gqslparameterlist verwenden.
\item Keine \gqsldeclaration darf den gleichen \gqslidentifier verwenden wie
eine \gqsldeclaration innerhalb eines \gqsldeclarationpart, deren Variablen
in dem selben \gqslquerybody bzw. \gqslscriptbody sichtbar sind (siehe
Kapitel \ref{language_variables}).
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Queries}
\label{language_queries}

\begin{EBNF}
\item[\gqslquery] ~\\
                  \tokquery \gqslidentifier \\
                  ~~ [ \tokopenbracket \gqslparameterlist \tokclosebracket ] \\
                  ~~ \tokreturn \gqsltype \tokis \\
                  ~~~ \gqsldeclarationpart \\
                  \tokbegin \\
                  ~~~ \gqslquerybody \\
                  ~~~ \tokreturn \gqslexpression \toksemicolon \\
                  \tokend \toksemicolon
\end{EBNF}

\begin{enumerate}
\item Definiert eine GQSL Query, die aus jeder anderen GQSL Query sowie aus
jedem GQSL Script durch den \gqslidentifier aufgerufen werden kann.
\item In dem \gqslquerybody und in der \gqslexpression sind alle Variablen
aus dem \gqsldeclarationpart,
alle Parameter aus der \gqslparameterlist, sowie alle dem System bekannten
GQSL Queries sichtbar. Sonst ist in dem \gqslquerybody nichts sichtbar.
\item Nach einem Aufruf werden die Parameter der Query erzeugt und mit
ihren Initialwerten belegt (siehe Kapitel \ref{language_parameter}), die
Variablen werden erzeugt (siehe Kapitel \ref{language_variables}) und
schließlich wird der \gqslquerybody ausgeführt (siehe Kapitel
\ref{language_querybody}).
\item Falls der \gqslquerybody erfolgreich ausgeführt wurde, dann wird die
\gqslexpression (siehe Kapitel \ref{language_expression}) ausgewertet.
Andernfalls ist die Ausführung der Query fehlerhaft.
\item Falls die \gqslexpression erfolgreich ausgewertet wurde, so wird ihr
Ergebnis zum Rückgabewert. Die Ausführung der Query ist erfolgreich.
Andernfalls ist die Ausführung der Query fehlerhaft.
\item Falls die Ausführung der Query erfolgreich ist, so werden ihre
Variablen und Parameter zerstört und die Ausführung der Query endet.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Scripts}
\label{language_scripts}

\begin{EBNF}
\item[\gqslscript] ~\\
                  \tokscript \gqslidentifier \\
                  ~~ [ \tokopenbracket \gqslparameterlist \tokclosebracket ] \\
                  ~~~ \gqsldeclarationpart \\
                  \tokbegin \\
                  ~~~ \gqslscriptbody \\
                  \tokend \toksemicolon
\end{EBNF}

\begin{enumerate}
\item Definiert ein GQSL Script, das von jedem GQSL Script durch den
\gqslidentifier aufgerufen werden kann. Das Script kann auch von einem
GQSL Interpreter direkt ausgeführt werden.
\item In dem \gqslquerybody und in der \gqslexpression sind alle Variablen
aus dem \gqsldeclarationpart,
alle Parameter aus der \gqslparameterlist, sowie alle dem System bekannten
GQSL Queries und GQSL Scripts sichtbar. Sonst ist in dem \gqslquerybody und
in der \gqslexpression nichts sichtbar.
\item Nach einem Aufruf werden die Parameter des Scripts erzeugt und mit
ihren Initialwerten belegt (siehe Kapitel \ref{language_parameter}), die
Variablen werden erzeugt (siehe Kapitel \ref{language_variables}) und
schließlich wird der \gqslscriptbody ausgeführt (siehe Kapitel
\ref{language_scriptbody}).
\item Falls der \gqslscriptbody erfolgreich ausgeführt wurde, dann ist die
Ausführung des Scripts erfolgreich. Andernfalls ist die Ausführung des Scripts
fehlerhaft.
\item Falls die Ausführung des Scripts erfolgreich ist, so werden seine
Variablen und Parameter zerstört und die Ausführung des Scripts endet.
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%
\subsubsection{Query Body}
\label{language_querybody}


\begin{EBNF}
\item[\gqslquerybody] \{ \gqslstatement \}
\end{EBNF}

\begin{enumerate}
\item Ein \gqslquerybody hat eine bestimmte \emph{Sicht}. Die Sicht ist die
Menge aller Object (genauer Variablen, Parameter, Queries und Scripts),
die in dem \gqslquerybody sichtbar sind
(vgl. Kapitel \ref{language_queries}). Ein Objekt ist in dem \gqslquerybody
sichtbar, genau dann wenn es in der Sicht enthalten ist.
\item Alle Nicht-Terminale, die aus dem \gqslquerybody abgeleitet sind
(die in einem Ableitungsbaum unter dem Symbol \gqslquerybody angeordnet sind),
haben die selbe Sicht wie der \gqslquerybody.
\item Ein \gqslquerybody wird ausgeführt, indem alle \gqslstatement in der
Reihenfolge einer Linksableitung der Grammatik ausgeführt werden. Sobald
ein \gqslstatement fehlerhaft ausgeführt wird, stoppt die Ausführung, es
wird keines der nachfogenden \gqslstatement ausgeführt und
der \gqslquerybody ist fehlerhaft ausgeführt.
\item Der \gqslquerybody ist erfolgreich ausgeführt, falls er entweder kein
\gqslstatement enthält oder falls das letzte \gqslstatement erfolgreich
ausgeführt wurde.
\item Die Ausführung des \gqslquerybody endet sobald er entweder erfolgreich
ausgeführt ist, oder fehlerhaft ausgeführt ist.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Script Body}
\label{language_scriptbody}

\begin{EBNF}
\item[\gqslscriptbody] \{ \gqslcomplexstatement \}
\end{EBNF}

\begin{enumerate}
\item Ein \gqslscriptbody hat eine bestimmte \emph{Sicht}. Die Sicht ist die
Menge aller Objekte (genauer Variablen, Parameter, Queries und Scripts),
die in dem \gqslscriptbody sichtbar sind
(vgl. Kapitel \ref{language_scripts}). Ein Objekt ist in dem \gqslscriptbody
sichtbar, genau dann wenn es in der Sicht enthalten ist.
\item Alle Nicht-Terminale, die aus dem \gqslscriptbody abgeleitet sind
(die in einem Ableitungsbaum unter dem Symbol \gqslscriptbody angeordnet sind),
haben die selbe Sicht wie der \gqslscriptbody.
\item Ein \gqslscriptbody wird ausgeführt, indem alle \gqslcomplexstatement
in der Reihenfolge einer Linksableitung der Grammatik ausgeführt werden. Sobald
ein \gqslcomplexstatement fehlerhaft ausgeführt wird, stoppt die Ausführung,
es wird keines der nachfolgenden \gqslstatement ausgeführt und der
\gqslscriptbody ist fehlerhaft ausgeführt.
\item Der \gqslscriptbody ist erfolgreich ausgeführt, falls er entweder kein
\gqslcomplexstatement enthält oder falls das letzte \gqslcomplexstatement
erfolgreich ausgeführt wurde.
\item Die Ausführung des \gqslscriptbody endet, sobald er entweder erfolgreich
ausgeführt ist, oder fehlerhaft ausgeführt ist.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Statement}

\begin{EBNF}
\item[\gqslstatement] \gqslassignment \toksemicolon
\item[\gqslassignment] \gqslidentifier \tokequal \gqslexpression
\end{EBNF}

\begin{enumerate}
\item Der \gqslidentifier muss entweder eine sichtbare Variable oder einen
sichtbaren Parameter bezeichnen. Diese/r Variable/Parameter wird $lhs$ genannt.
\item Der Typ der \gqslexpression muss der selbe Typ sein wie der Typ von $lhs$
\item Zur Ausführung des \gqslstatement wird die \gqslexpression ausgewertet.
Falls die \gqslexpression erfolgreich ausgewertet wurde, so wird der Wert
von $lhs$ auf das Ergebnis der \gqslexpression geändert. In diesem Fall ist
die Ausführung des \gqslstatement erfolgreich.
\item Falls \gqslexpression fehlerhaft ausgewertet wurde, dann ist die
Ausführung des \gqslstatement fehlerhaft.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Complex Statement}
\label{language_complexstatement}

\begin{EBNF}
\item[\gqslcomplexstatement] \gqslstatement | \gqslscriptcall \toksemicolon
\item[\gqslscriptcall] \gqslidentifier [ ( \gqslargumentlist ) ]
\item[\gqslargumentlist] \gqslexpression \{ \tokcomma \gqslexpression  \}
\end{EBNF}

\begin{description}
\item[\gqslstatement]
  \begin{enumerate}
  \item Die Sicht des \gqslstatement ist die selbe wie die Sicht des
  \gqslcomplexstatement
  \item Zum Ausführen des \gqslcomplexstatement wird das \gqslstatement
  ausgeführt.
  \item Das \gqslcomplexstatement ist erfogreich ausgeführt, falls das
  \gqslstatement erfolgreich ausgeführt ist.
  \item Das \gqslcomplexstatement ist fehlerhaft ausgeführt, falls das
  \gqslstatement fehlerhaft ausgeführt ist.
  \end{enumerate}
\item[\gqslscriptcall]
  \begin{enumerate}
  \item \gqslidentifier muss ein sichtbares GQSL Script $S$ bezeichnen.
  \item Falls $S$ keine \gqslparameterlist besitzt, so darf keine
  \gqslargumentlist angegeben sein.
  \item Falls $S$ eine \gqslparameterlist besitzt, so müssen in der
  \gqslargumentlist genau so viele \gqslexpression angegeben sein, wie in der
  \gqslparameterlist \gqsldeclaration angegeben sind.
  \item Der Typ der $i$-ten \gqslexpression der \gqslargumentlist muss der
  selbe sein wie der Typ der $i$-ten \gqsldeclaration der \gqslparameterlist
  für alle $i$.
  \item Zum Ausführen des \gqslcomplexstatement werden alle \gqslexpression
  in durch den Interpreter bestimmter Reihenfolge ausgewertet.
  \item Falls eine der \gqslexpression fehlerhaft ausgewertet wird,
  so ist die Ausführung des \gqslcomplexstatement fehlerhaft. Andernfalls
  wird $S$ aufgerufen. Der $i$-te Parameter wird mit dem Wert der $i$-ten
  \gqslexpression initialisiert für alle $i$.
  \item Falls $S$ erfolgreich ausgeführt wurde, so ist das
  \gqslcomplexstatement erfolgreich ausgeführt. Falls $S$ fehlerhaft
  ausgeführt wurde, so ist das \gqslcomplexstatement fehlerhaft ausgeführt.
  \end{enumerate}
\end{description}

Die Ausführung des \gqslcomplexstatement endet, sobald es entweder erfolgreich
oder fehlerhaft ausgeführt ist.


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Expression}
\label{language_expression}

\begin{EBNF}
\item[\gqslexpression] ~\\
                       \gqslnodesetexpression  \\
                       | \gqsledgesetexpression \\
                       | \gqslsubgraphexpression \\
                       | \gqslselectionexpression \\
                       | \gqslvariableinspection \\
                       | \gqslquerycall \\
                       | \gqslcalculation \\
                       | \gqslliteralexpression
\end{EBNF}

Annahme: Aus den Alternativen sei die Regel mit der rechten Seite
$R$ gewählt ($R$ besteht aus genau einem Nicht-Terminal).
\begin{enumerate}
\item Der Typ der \gqslexpression ist der Typ des Nicht-Terminals $R$
(siehe die folgenden Kapitel für Details).
\item Die \gqslexpression wird erfolgreich ausgewertet, falls $R$ erfolgreich
ausgewertet wird. Andernfalls ist die \gqslexpression fehlerhaft ausgewertet.
\item Falls $R$ erfolgreich ausgewertet wird, so ist der Wert der
\gqslexpression gleich dem Wert der Auswertung von $R$.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Node Set Expression}

\begin{EBNF}
\item[\gqslnodesetexpression] \tokselect \toknodes \tokfrom \gqslexpression
                              [ \gqslnodepredicate ] \\
                             | \tokbuild \toknodes \tokfrom \gqslexpression
                              [ \tokaccept \toknodes \gqslnodepredicate ] \\
                             | \tokallnodes \\
                             | \tokrootnode
\end{EBNF}

Der Typ einer \gqslnodesetexpression ist \toknodeset.

\begin{description}
\item[select]
  Trifft eine Auswahl bestimmter IML-Knoten aus einer Menge.
  \begin{enumerate}
  \item Der Typ von \gqslexpression muss \toknodeset, \toksubgraph oder
  \tokselection sein.
  \item Die Auswertung ist erfolgreich genau dann, wenn die Auswertung der
  \gqslexpression erfolgreich ist. Andernfalls ist die Auswertung fehlerhaft.
  \item Ist die Auswertung erfolgreich, dann ist das Ergebnis die größte
  Menge $M$ von IML-Knoten, so dass $\forall v \in M$
    \begin{enumerate}
    \item $v$ ist in \gqslexpression enthalten.
    \item $v$ erfüllt das \gqslnodepredicate, falls dieses angegeben ist
    (siehe Kapitel \ref{language_node_predicate}).
    \end{enumerate}
  \end{enumerate}
\item[build]
  Bildet eine Menge von IML-Knoten, die inzident sind zu einer gegebenen Menge
  von IML-Kanten.
  \begin{enumerate}
  \item Der Typ von \gqslexpression muss \tokedgeset sein.
  \item Die Auswertung ist erfolgreich genau dann, wenn die Auswertung von
  \gqslexpression erfolgreich ist. Andernfalls ist die Auswertung fehlerhaft.
  \item Ist die Auswertung erfolgreich, dann ist das Ergebnis die größte
  Menge $M$ von IML-Knoten, so dass $\forall v \in M$
    \begin{enumerate}
    \item $v$ ist inzident zu einer Kante $e$ aus \gqslexpression
    \item $v$ erfüllt \gqslnodepredicate, falls dieses angegeben ist.
    \end{enumerate}
  \end{enumerate}
\item[\tokallnodes]
  Die Menge aller IML-Knoten des IML-Graphen.
  \begin{enumerate}
  \item Die Auswertung ist stets erfolgreich.
  \item Das Ergebnis ist die Menge aller IML-Knoten des IML-Graphen.
  \end{enumerate}
\item[\tokrootnode]
  Die Wurzel des IML-Graphen.
  \begin{enumerate}
  \item Die Auswertung ist stets erfolgreich.
  \item Das Ergebnis ist die Menge, die den Wurzelknoten des dem IML-Graphen
  zugrundeliegenden IML-Programms enthält und sonst nichts.
  \end{enumerate}
\end{description}



%%%%%%%%%%%%%%%%%%%%
\subsubsection{Edge Set Expression}

\begin{EBNF}
\item[\gqsledgesetexpression] \tokselect \tokedges \tokfrom \gqslexpression
                              [ \gqsledgepredicate ] \\
                             | \tokbuild \tokedges [ \tokfrom \gqslexpression ]
                                                   [ \tokto \gqslexpression ]
                                                   [ \gqsledgepredicate ]
\end{EBNF}

Der Typ einer \gqsledgesetexpression ist \tokedgeset.

\begin{description}
\item[select] Trifft eine Auswahl von bestimmten IML-Kanten aus einer Menge.
  \begin{enumerate}
  \item Der Typ von \gqslexpression muss \tokedgeset, \toksubgraph oder
  \tokselection sein.
  \item Die Auswertung ist erfolgreich genau dann, wenn die Auswertung von
  \gqslexpression erfolgreich ist. Andernfalls ist die Auswertung fehlerhaft.
  \item Falls die Auswertung erfolgreich ist, dann ist das Ergebnis die
  größte Menge von IML-Kanten $M$ mit $\forall e \in M$
    \begin{enumerate}
    \item $e$ ist in der Menge der IML-Kanten aus \gqslexpression enthalten.
    \item $e$ erfüllt \gqsledgepredicate, falls das angegeben ist.
    (siehe Kapitel \ref{language_edge_predicate})
    \end{enumerate}
  \end{enumerate}
\item[build] Bildet eine Menge von IML-Kanten, die zwischen zwei Mengen
von IML-Knoten verlaufen.
  \begin{enumerate}
  \item Beide \gqslexpression müssen -- sofern sie angegeben sind -- den
  Typ \toknodeset haben.
  \item Die Auswertung ist erfolgreich, falls alle angegebenen
  \gqslexpression erfolgreich ausgewertet werden. Andernfalls ist die
  Auswertung fehlerhaft.
  \item Das Ergebnis ist die Menge $M$ aller IML-Kanten mit $\forall
  e \in M$
    \begin{enumerate}
    \item $e$ ist im IML-Graph enthalten.
    \item Der Start-Knoten von $e$ ist in der \tokfrom-\gqslexpression
    enthalten, falls \tokfrom-\gqslexpression angegeben ist.
    \item Der Ziel-Knoten von $e$ ist in der \tokto-\gqslexpression
    enthalten, falls \tokto-\gqslexpression angegeben ist.
    \item $e$ erfüllt das \gqsledgepredicate.
    \end{enumerate}
  \end{enumerate}
\end{description}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Subgraph Expression}

\begin{EBNF}
\item[\gqslsubgraphexpression] \tokmake \tokgraph \tokopenbracket
                                    \gqslexpression \tokcomma \gqslexpression
                                    \tokclosebracket \\
                               | \tokbuild \tokgraph \tokbased \tokon
                                    \gqslexpression \tokfollow \tokedges
                                    \gqsledgepredicate
                                    [ \tokaccept \toknodes \gqslnodepredicate ]
                                    [ \tokuntil \tokdepth \gqslexpression ]
\end{EBNF}

Der Typ einer \gqslsubgraphexpression ist immer \toksubgraph.

\begin{description}
\item[make] Erstellt einen IML-Teilgraph aus einer Menge von Knoten und einer
Menge von Kanten.
  \begin{enumerate}
  \item Der Typ der ersten \gqslexpression muss \toknodeset sein.
  \item Der Typ der zweiten \gqslexpression muss \tokedgeset sein.
  \item Die Auswertung ist erfolgreich genau dann, wenn die Auswertung beider
  \gqslexpression erfolgreich ist. Andernfalls ist die Auswertung fehlerhaft.
  \item Falls die Auswertung erfolgreich ist, so ist das Ergebnis ein
  IML-Teilgraph mit allen IML-Knoten der ersten
  \gqslexpression sowie denjenigen IML-Kanten die in der zweiten
  \gqslexpression enthalten sind und deren Start- und Zielknoten in der
  ersten \gqslexpression enthalten sind.
  \end{enumerate}
\item[build] Fragt einen Teilgraph an, ausgehend von einer Grundmenge von
IML-Knoten.
  \begin{enumerate}
  \item Der Typ der ersten \gqslexpression muss \toknodeset sein.
  \item Falls die zweite \gqslexpression angegeben ist, so muss ihr Typ
  \tokinteger sein.
  \item Die Auswertung ist erfolgreich falls die folgenden Bedingungen
  erfüllt sind:
    \begin{enumerate}
    \item Alle \gqslexpression werden erfolgreich ausgewertet.
    \item Falls die zweite \gqslexpression angegeben ist, so ist ihr Wert
    größer oder gleich 0.
    \end{enumerate}
  andernfalls ist die Auswertung fehlerhaft.
  \item Der Wert ergibt sich durch eine Breitensuche auf dem IML-Graph.
  Begonnen wird mit der IML-Knotenmenge, die durch die erste \gqslexpression
  gegeben ist (Ebene 0). Dann werden alle IML-Kanten verfolgt für die
    \begin{enumerate}
    \item Das \gqsledgepredicate erfüllt ist.
    \item Der über diese IML-Kante erreichte IML-Knoten das \gqslnodepredicate
    erfüllt, sofern dieses angegeben ist.
    \item Die Nummer der Ebene kleiner ist als die zweite \gqslexpression,
    sofern diese angegeben ist.
    \end{enumerate}
  Wurde eine IML-Kante verfolgt, so wird sie zum Ergebnis hinzugefügt. Der
  erreichte IML-Knoten wird ebenfalls zum Ergebnis hinzugefügt. Die Menge
  aller so erreichten IML-Knoten bildet die Ausgangsmenge für den nächsten
  Schritt. Sie ist eine Ebene höher. Die Suche bricht ab, wenn keine neuen
  Kanten mehr aufgenommen werden.
  \end{enumerate}
\end{description}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Selection Expression}

\begin{EBNF}
\item[\gqslselectionexpression] \tokmake \tokselection \tokopenbracket
                                   \gqslexpression \tokcomma \tokclosebracket
\end{EBNF}

\begin{enumerate}
\item die erste \gqslexpression muss den Typ \toknodeset haben.
\item die zweite \gqslexpression muss den Typ \tokedgeset haben.
\item Der Typ der \gqslselectionexpression ist \tokselection.
\item Die Auswertung ist erfolgreich genau dann, wenn die Auswertung beider
\gqslexpression erfolgreich ist. Andernfalls ist die Auswertung fehlerhaft.
\item Falls die Auswertung erfolgreich ist, dann ist der Wert die Selektion,
die alle IML-Knoten und alle IML-Kanten aus den beiden \gqslexpression und
sonst nichts enthält.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Variable Inspection}

\begin{EBNF}
\item[\gqslvariableinspection] \gqslidentifier
\end{EBNF}

\begin{enumerate}
\item Der \gqslidentifier muss entweder eine sichtbare Variable oder einen
sichtbaren Parameter $v$ bezeichnen.
\item Der Typ der \gqslvariableinspection ist der Typ von $v$.
\item Eine \gqslvariableinspection wird stets erfolgreich ausgewertet.
\item Der Wert der \gqslvariableinspection ist der Wert, den $v$ zum Zeitpunkt
der Auswertung hat.
\end{enumerate}

\begin{description}
\item[Anmerkung] Eine \gqslvariableinspection kann nur während der Lebenszeit
einer Variable bzw. eines Parameters geschehen. Eine Variable hat zu jedem
Zeitpunkt ihrer Lebenszeit einen Wert. (vgl. Kapitel \ref{language_variables},
\ref{language_parameter})
\item[Anmerkung] Der Wert von $v$ verändert sich durch die
\gqslvariableinspection nicht.
\end{description}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Query Call}

\begin{EBNF}
\item[\gqslquerycall] \gqslidentifier [ \tokopenbracket \gqslargumentlist
                                        \tokclosebracket ]
\end{EBNF}

Anmerkung: \gqslargumentlist siehe \ref{language_complexstatement}

\begin{enumerate}
\item \gqslidentifier muss eine sichtbare GQSL Query $Q$ bezeichnen.
\item Falls $Q$ keine \gqslparameterlist besitzt, so darf keine
\gqslargumentlist angegeben sein.
\item Falls $Q$ eine \gqslparameterlist besitzt, so müssen in der
\gqslargumentlist genau so viele \gqslexpression angegeben sein, wie in der
\gqslparameterlist \gqsldeclaration angegeben sind.
\item Der Typ der $i$-ten \gqslexpression der \gqslargumentlist muss
der selbe sein wie der Typ der $i$-ten \gqsldeclaration der
\gqslparameterlist für alle $i$.
\item Der Typ des \gqslquerycall ist der Wert des Rückgabewerts von $Q$.
\item Zum Auswerten des \gqslquerycall werden alle \gqslexpression
in durch den Interpreter willkürlich bestimmter Reihenfolge ausgewertet.
\item Falls eine der \gqslexpression fehlerhaft ausgewertet wird,
so ist die Auswertung des \gqslquerycall fehlerhaft. Andernfalls
wird $Q$ aufgerufen. Der $i$-te Parameter wird mit dem Wert der $i$-ten
\gqslexpression initialisiert für alle $i$.
\item Falls $Q$ erfolgreich ausgeführt wurde, so ist der
\gqslquerycall erfolgreich ausgewertet. Falls $W$ fehlerhaft
ausgeführt wurde, so ist der \gqslquerycall fehlerhaft ausgewertet.
\item Falls der \gqslquerycall erfolgreich ausgewertet wurde, so ist
sein Wert gleich dem Rückgabewert von $Q$.
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%
\subsubsection{Calculation}

\begin{EBNF}
\item[\gqslcalculation] \tokopenbracket \gqslexpression \tokclosebracket \\
                       | \gqslexpression \tokplus \gqslexpression \\
                       | \gqslexpression \tokminus \gqslexpression \\
                       | \gqslexpression \tokintersect \gqslexpression
\end{EBNF}


%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Literal Expression}

\begin{EBNF}
\item[\gqslliteralexpression] \gqslintliteral \\
                       | \gqslstringliteral
\end{EBNF}

Eine \gqslliteralexpression wird stets erfolgreich ausgewertet.
\begin{description}
\item[\gqslintliteral]
   \begin{enumerate}
   \item Der Typ der \gqslliteralexpression ist \tokinteger.
   \item Der Wert der \gqslliteralexpression ist die Interpretation die
   Ableitung des \gqslintliteral im 10er Zahlensystem.
   \end{enumerate}
\item[\gqslstringliteral]
   \begin{enumerate}
   \item Der Typ der \gqslliteralexpression ist \tokstring.
   \item Der Wert der \gqslliteralexpression ist die Ableitung
   des \gqslstringliteral.
   \end{enumerate}
\end{description}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Logik}

\begin{EBNF}
\label{language_node_predicate}
\item[\gqslnodepredicate]
\label{language_edge_predicate}
\item[\gqsledgepredicate]
\end{EBNF}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{GQSL vordefinierte Sprachumgebung}
\label{language_gqsl_predef_env}

\paragraph{Vordefinierte Queries}

\begin{verbatim}
Get_Current_Window
  return string is
// ... implementation defined ...
\end{verbatim}

Liefert als Ergebnis den Namen des Anzeigefensters, in dessen Kontext
der GQSL Interpreter sich befindet. Befindet sich der GQSL Interpreter
nicht im Kontext eines Anzeigefensters, so ist das Ergebnis undefiniert.

\begin{verbatim}
Get_Current_Selection
  (Window_Name : string)
  return selection is
// ... implementation defined ...
\end{verbatim}

Erhält als Argument den Namen eines Anzeigefensters und liefert als
Ergebnis die aktuelle Selektion in diesem Anzeigefenster.
Kein Anzeigefenster dieses Namens existiert, ist das Ergebnis undefiniert.

\begin{verbatim}
Get_Selection
  (Window_Name    : string;
   Selection_Name : string)
  return selection is
// ... implementation defined ...
\end{verbatim}

Erhält als erstes Argument den Namen eines Anzeigefensters, als zweites
Argument den Namen einer Selektion in diesem Anzeigefenster. Liefert als
Ergebnis die durch diese Namen gewählte Selektion. Existiert kein
Anzeigefenster des gewählten Namens oder existiert in dem Anzeigefenster
keine Selektion des gewählten Namens, so ist das Ergebnis undefiniert.

\begin{verbatim}
Get_Subgraph
  (Subgraph_Name : string)
  return subgraph is
// ... implementation defined ...
\end{verbatim}

Erhält als Argument den Namen eines IML-Teilgraphen. Liefert als Ergebnis
den IML-Teilgraphen des gewählten Namens. Existiert kein IML-Teilgraph
dieses Namens, so ist das Ergebnis undefiniert.

\paragraph{Vordefinierte Scripts}

\begin{verbatim}
Create_Window
  (Window_Name : string;
   Layout_Algo : string;
   Content     : subgraph) is
// ... implementation defined ...
\end{verbatim}

Erzeugt ein neues Anzeigefenster mit dem Namen \texttt{Window\_Name}.
Wendet den Layout-Algorithmus \texttt{Layout\_Algo} auf \texttt{Content}
an und fügt die so erzeugte neue Selektion in das Anzeigefenster ein.

Falls \texttt{Window\_Name} keinen gültigen Namen für ein Anzeigefenster
enthält oder falls bereits ein Anzeigefenster dieses Namens existiert,
so ist die Ausführung dieses Scripts fehlerhaft. Falls
\texttt{Layout\_Algo} kein gültiger Layout-Algorithmus ist, so ist die
Ausführung dieses Scripts fehlerhaft.

\begin{verbatim}
Insert_Into_Window
  (Window_Name : string;
   Layout_Algo : string;
   New_Content : subgraph) is
// ... implementation defined ...
\end{verbatim}

Wendet den Layout-Algorithmus \texttt{Layout\_Algo} auf \texttt{Content}
an und fügt die so erzeugte neue Selektion in das Anzeigefenster mit
dem Namen \texttt{Window\_Name} ein.

Falls  kein Anzeigefenster des Namens \texttt{Window\_Name} existiert,
so ist die Ausführung dieses Scripts fehlerhaft. Falls
\texttt{Layout\_Algo} kein gültiger Layout-Algorithmus ist, so ist die
Ausführung dieses Scripts fehlerhaft.

\begin{verbatim}
Set_Subgraph
  (Subgraph_Name : string;
   Value         : subgraph) is
// ... implementation defined ...
\end{verbatim}

Falls noch kein IML-Teilgraph mit Name \texttt{Subgraph\_Name}
Name existiert, dann erzeugt diesen IML-Teilgraphen. Setzt den Inhalt
des IML-Teilgraphen mit Name \texttt{Subgraph\_Name} auf \texttt{Value}.

Falls \texttt{Subgraph\_Name} kein gültiger Name für IML-Teilgraphen ist,
so ist die Ausführung dieses Scripts fehlerhaft.
