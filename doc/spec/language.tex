% =============================================================================
%  $RCSfile: language.tex,v $, $Revision: 1.6 $
%  $Date: 2003/04/08 05:24:52 $
%  $Author: keulsn $
%
%  Description:
%
%  Last-Ispelled-Revision: 1.1
%
% =============================================================================

%%%% Non-terminals
\nonterminal{\gqslargumentlist}{argument\_list}
\nonterminal{\gqslassignment}{assignment}
\nonterminal{\gqslatomicsloc}{atomic\_sloc}
\nonterminal{\gqslatomiclinktarget}{atomic\_link\_target}
\nonterminal{\gqslatomiclistchoice}{atomic\_list\_choice}
\nonterminal{\gqslatomicsize}{atomic\_size}
\nonterminal{\gqslatomicstringlist}{atomic\_string\_list}
\nonterminal{\gqslatomictargettype}{atomic\_target\_type}
\nonterminal{\gqslatomicvalue}{atomic\_value}
\nonterminal{\gqslattribatomicvalue}{attrib\_atomic\_value}
\nonterminal{\gqslattribexpr}{attrib\_expr}
\nonterminal{\gqslattribproduct}{attrib\_product}
\nonterminal{\gqslattribstatement}{attrib\_statement}
\nonterminal{\gqslcalculation}{calculation}
\nonterminal{\gqslcomplexstatement}{complex\_statement}
\nonterminal{\gqslcompop}{compare\_operator}
\nonterminal{\gqsldeclaration}{declaration}
\nonterminal{\gqsldeclarationpart}{declaration\_part}
\nonterminal{\gqsldigit}{digit}
\nonterminal{\gqsledgechoosingproduct}{edge\_choosing\_product}
\nonterminal{\gqsledgechoosingstatement}{edge\_choosing\_statement}
\nonterminal{\gqsledgepredicate}{edge\_predicate}
\nonterminal{\gqsledgesetexpression}{edge\_set\_expression}
\nonterminal{\gqslexpression}{expression}
\nonterminal{\gqslidentifier}{identifier}
\nonterminal{\gqslintliteral}{int\_literal}
\nonterminal{\gqslletter}{letter}
\nonterminal{\gqslliteralexpression}{literal\_expression}
\nonterminal{\gqslnodechoosingproduct}{node\_choosing\_product}
\nonterminal{\gqslnodechoosingstatement}{node\_choosing\_statement}
\nonterminal{\gqslnodepredicate}{node\_predicate}
\nonterminal{\gqslnodesetexpression}{node\_set\_expression}
\nonterminal{\gqslparameterlist}{parameter\_list}
\nonterminal{\gqslquery}{query}
\nonterminal{\gqslquerybody}{query\_body}
\nonterminal{\gqslquerycall}{query\_call}
\nonterminal{\gqslregexp}{regexp}
\nonterminal{\gqslregexpchar}{regexp\_char}
\nonterminal{\gqslscript}{script}
\nonterminal{\gqslscriptbody}{script\_body}
\nonterminal{\gqslscriptcall}{script\_call}
\nonterminal{\gqslselectionexpression}{selection\_expression}
\nonterminal{\gqslsimplenodechoice}{simple\_node\_choice}
\nonterminal{\gqslsimpleedgechoice}{simple\_edge\_choice}
\nonterminal{\gqslsimpleattribstatement}{simple\_attrib\_statement}
\nonterminal{\gqslstatement}{statement}
\nonterminal{\gqslstringchar}{string\_char}
\nonterminal{\gqslstringliteral}{string\_literal}
\nonterminal{\gqslsubgraphexpression}{subgraph\_expression}
\nonterminal{\gqsltype}{type}
\nonterminal{\gqslvariableinspection}{variable\_inspection}

%%%% Tokens
\token{\tokaccept}{accept}
\token{\tokand}{and}
\token{\tokallnodes}{all\_nodes}
\token{\tokbased}{based}
\token{\tokbegin}{begin}
\token{\tokbegincomment}{//}
\token{\tokbeginrequote}{<}
\token{\tokbuild}{build}
\token{\tokclosebracket}{)}
\token{\tokcolon}{:}
\token{\tokcolumn}{column}
\token{\tokcomma}{,}
\token{\tokdepth}{depth}
\token{\tokdifferent}{!=}
\token{\tokdot}{.}
\token{\tokedges}{edges}
\token{\tokedgeset}{edge\_set}
\token{\tokend}{end}
\token{\tokendrequote}{>}
\token{\tokequal}{=}
\token{\tokfilename}{file\_name}
\token{\tokfollow}{follow}
\token{\tokfrom}{from}
\token{\tokgraph}{graph}
\token{\tokgreater}{>}
\token{\tokgreaterequal}{>=}
\token{\tokhaving}{having}
\token{\tokin}{in}
\token{\tokintersect}{intersect}
\token{\tokinteger}{integer}
\token{\tokis}{is}
\token{\tokline}{line}
\token{\tokmake}{make}
\token{\tokminus}{-}
\token{\toknodes}{nodes}
\token{\toknodeset}{node\_set}
\token{\toknot}{not}
\token{\tokon}{on}
\token{\tokopenbracket}{(}
\token{\tokor}{or}
\token{\tokpath}{path}
\token{\tokplus}{+}
\token{\tokquery}{query}
\token{\tokquote}{''}
\token{\tokreturn}{return}
\token{\tokrootnode}{root\_node}
\token{\tokscript}{script}
\token{\tokselect}{select}
\token{\tokselection}{selection}
\token{\toksemicolon}{;}
\token{\toksize}{size}
\token{\toksmaller}{<}
\token{\toksmallerequal}{<=}
\token{\tokstring}{string}
\token{\toksubgraph}{subgraph}
\token{\toktargettype}{target\_type}
\token{\tokto}{to}
\token{\toktype}{type}
\token{\tokuntil}{until}


In diesem Kapitel wird die GIANT Query and Scripting Language (GQSL) sowie
Interpreter für die GQSL spezifiziert. GQSL ist eine Sprache mit deren
Hilfe Anfragen an die IML-Bibliothek gestellt werden und auf den Resultaten
Aktionen ausgeführt werden können.

Hier wird zunächst die Struktur von IML-Graphen aus der Sicht
von GIANT beschrieben und danach Syntax und Sematik von GQSL definiert.

\section{IML-Graphen}

Der Kunde stellt die Reflektion zur Verfügung. GIANT verwendet diese
Bibliothek, um auf IML-Graph Dateien zuzugreifen.

\subsection{IML-Programme}
\index{IML-Graph Datei!Inhalt}

In jeder IML-Graph Datei ist ein IML-Programm enthalten. Das IML-Programm
besteht aus
\begin{enumerate}
\item IML-Knoten
\item Attributen von IML-Knoten
\item nichts sonst.
\end{enumerate}

Es gibt in jedem IML-Programm einen besonderen IML-Knoten, der Wurzelknoten
genannt wird.

\subsubsection{Attribute von IML-Knoten}

Jeder IML-Knoten hat einen Typ. Für jeden Typ von IML-Knoten existiert ein
String, der den Typ eineindeutig identifiziert.

Jeder IML-Knoten verfügt über eine Folge von Attributen.
Diese Folge definiert eine endliche Anzahl einzelner Attribute,
die der IML-Knoten besitzt sowie eine Reihenfolge dieser Attribute.
Weder die Folge von Attributen noch die in der Folge enthaltenen
Attribute eines IML-Knoten können sich während der Laufzeit von
GIANT verändern.

Jedes Attribut besitzt einen Attribut-Namen. Kein IML-Knoten besitzt
zwei verschiedene Attribute, die einen gleichen Namen besitzen.

Einige Attribute sind Verweise. Sie verweisen auf höchstens einen
IML-Knoten. Es werden unterschieden:
\begin{description}
\item[genutzte Verweise] Verweise, die auf genau einen
           IML-Knoten verweisen.
\item[ungenutzte Verweise] Verweise, die auf nichts verweisen.
\end{description}

Jedes Attribut eines IML-Knoten gehört genau einer der folgenden Klassen an:
\begin{description}
\item[Einfache Attribute]: Haben einen bestimmten Wert.
           Mögliche Typen dieses Werts sind:
           \begin{enumerate}
           \item Source Location
                 \begin{enumerate}
                 \item Zeilennummer (Natural)
                 \item Spaltennummer (Natural)
                 \item Filename (String)
                 \item Pfadname (String)
                 \end{enumerate}
           \item Boolean
           \item Natural
           \item String
           \item Folge von Strings
           \end{enumerate}
\item[Bezeichner-Attribut] Haben als Wert einen String
\item[Genutztes Verweis-Attribut] Ein genutzter Verweis
\item[Ungenutztes Verweis-Attribut] Ein ungenutzter Verweis
\item[Verweisfolgen-Attribut] Eine endliche Folge von
           genutzten Verweisen
\item[Verweismengen-Attribut] Eine endliche Menge
           von genutzten Verweisen
\end{description}



\subsection{IML-Graphen}

Jedes IML-Programm definiert einen zugehörigen IML-Graph.
Sprechweise: Das IML-Programm liegt dem IML-Graph zugrunde.
Ein IML-Graph ist ein gerichteter knoten- und kantenannotierter Graph mit
Schlingen und Mehrfachkanten. Er ist definiert durch die folgende
Vorschrift:

\begin{enumerate}
\item
Ein IML-Graph besitzt als Knotenmenge die Menge aller IML-Knoten des
zugrunde liegenden IML-Programms. Der IML-Graph besitzt keine
weiteren Knoten.
\item
Annotationen eines IML-Knoten sind alle Attribute des IML-Knoten.
\item
\label{language_edge_spec}
Eine Kante im IML-Graph heißt IML-Kante. Eine IML-Kante $e$ von einem
IML-Knoten $v$ zu einem IML-Knoten $w$ des selben IML-Graph existiert
genau dann, wenn eine der folgenden Bedingungen erfüllt ist:
   \begin{enumerate}
   \item $v$ besitzt ein Genutztes Verweis-Attribut, das auf $w$ verweist.
         $e$ besitzt als Annotation den Attribut-Namen des Genutzten
         Verweis-Attributs. Dieser Attribut-Name ist der Typ von $e$
   \item $v$ besitzt ein Verweisfolgen-Attribut $f$. Ein genutzter Verweis
         aus $f$ verweist auf $w$. $e$ besitzt als Annotation den
         Attribut-Namen von $f$ sowie die Nummer innerhalb der Folge
         $f$ des genutzten Verweises auf $w$. Der Attribut-Name von $f$
         ist der Typ von $e$.
   \item $v$ besitzt ein Verweismengen-Attribut $m$. Ein genutzter Verweis
         aus $m$ verweist auf $w$. $e$ besitzt als Annotation den
         Attribut-Namen von $m$. Der Attribut-Name von $m$ ist der Typ von $e$.
   \end{enumerate}
\item
Falls eine IML-Kante $e$ existiert, so hat $e$ keine Annotationen,
außer den in Punkt \ref{language_edge_spec} genannten.
\end{enumerate}



\section{GQSL}

Die GIANT Query \& Scripting Language dient dazu, IML-Teilgraphen und
Selektionen aus einem IML-Graph anzufragen und auf diesen Aktionen
auszuführen.

Die Sprache lässt sich in zwei zentrale Konstrukte gliedern:
\begin{description}
\item[Queries] dienen der Anfrage eines Werts.
\item[Scripts] werden verwendet, um Aktionen auszuführen.
\end{description}

Als Aktion wird die Ausführung eines vordefinierten Scripts bezeichnet
(siehe Kapitel \ref{language_gqsl_predef_env}).
Aktionen können GIANT zu Reaktionen veranlassen, die für den Benutzer
wahrnehmbar werden und für seine Arbeit nützlich sein können
(z.B. Anzeigen eines IML-Teilgraphen in einem Anzeigefenster).


GQSL Queries können nicht direkt ausgeführt, sondern nur von GQSL Scripts
aufgerufen werden.
GQSL Scripts werden von einem GQSL Interpreter ausgeführt. 
Scripts können Queries aufrufen, um Daten zu gewinnen. Mit diesen Daten
sollen Aktionen nach den Wünschen des Benutzers konfiguriert werden.
Queries und Scripts können in Variablen Werte zwischenspeichern.


\subsection{GQSL Interpreter}

Ein GQSL Interpreter ist ein System, das GQSL Scripts ausführt, gemäß
der Sprachdefinition in Kapitel \ref{language_gqsl_spec}. Jeder GQSL
Interpreter muss die vordefinierte Sprachumgebung gemäß Kapitel
\ref{language_gqsl_predef_env} unterstützen.

\subsubsection{Kontext des Interpreters}

Der GQSL Interpreter kann im Kontext eines Anzeigefensters ausgeführt
werden. Ist dies der Fall, so sollen die ausgeführten GQSL Scripts und
GQSL Queries Zugriff auf das Anzeigefenster haben, ohne den Namen des
Anzeigefensters zu kennen.

Der Zugriff auf das Anzeigefenster in dessen Kontext der GQSL Interpreter
ausgeführt wird, soll über vordefinierte Queries durchgeführt
werden.

\subsubsection{Verhalten im Fehlerfall}

Der GQSL Interpreter muss ein Script bzw. eine Query zurückweisen, falls eine
Forderung der Sprachdefinition von diesem Script bzw. dieser Query verletzt
wird. In diesem Fall muss der Interpreter dem Benutzer eine Fehlermeldung
anzeigen, die folgende Anforderungen erfüllt:
\begin{enumerate}
\item Der Benutzer wird informiert, dass der Text des Scripts bzw. der Query
fehlerhaft ist.
\item Dem Benutzer wird die Art des Fehlers präzise erläutert.
\item Dem Benutzer wird angezeigt an welcher Stelle in welchem Script bzw.
in welcher Query der Fehler erkannt oder verursacht wurde.
\end{enumerate}
Andernfalls startet der GQSL Interpreter die Ausführung.

Der GQSL Interpreter muss die Ausführung sofort
stoppen, sobald die erste \gqslexpression fehlerhaft ausgewertet wird
oder sobald ein \gqslstatement oder \gqslcomplexstatement fehlerhaft
ausgeführt wird. Diese Ereignisse werden als Fehler angesehen.
Der GQSL Interpreter
darf die Ausführung bereits nach einem früheren Ausführungsschritt abbrechen,
wenn sichergestellt ist, dass nach einem späteren Ausführungsschritt
einer der genannten Fälle eintreten wird.

Der GQSL Interpreter muss dem Benutzer unverzüglich eine
Meldung anzeigen, die folgende Anforderungen erfüllt:
\begin{enumerate}
\item Der Benutzer muss informiert werden, dass ein Fehler aufgetreten ist.
\item Dem Benutzer muss präzise und für ihn leicht verständlich erläutert
werden, welcher Fehler aufgetreten ist.
\item Dem Benutzer kann eine Möglichkeit aufgezeigt werden, wie er den
Fehler beseitigen kann um eine fehlerfreie Ausführung des selben Scripts zu
ermöglichen.
\end{enumerate}

Der GQSL Interpreter muss nach einem Fehler entweder alle seit Beginn
der Ausführung bereits ausgeführten Aktionen rückgängig machen, oder er
muss dem Benutzer anzeigen, welche Aktionen bereits durchgeführt wurden,
bevor der Fehler passierte. Anhand dieser Information soll es dem Benutzer
möglich sein, die Aktionen manuell rückgängig zu machen.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{GQSL Sprachdefinition}
\label{language_gqsl_spec}

Die Syntax von GQSL wird beschrieben in Anlehnung an die
Beschreibungsmethode des Ada Reference Manual. Siehe ARM Kapitel 1.1.4 für
Details.


%%%%%%%%%%%%%%%%%%%%
\subsubsection{White Space}

Leerzeichen, Tabulatoren, Zeilenumbrüche und Kommentare können als
Trennzeichen verwendet werden.

Kommentare werden durch \tokbegincomment eingeleitet und gehen immer
bis zum Zeilenende.


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Schlüsselwörter}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Bezeichner}

\begin{EBNF}
\item[\gqslidentifier] \gqslletter \{~\gqslletter | \gqsldigit~\}
\end{EBNF}

\begin{enumerate}
\item
\gqslletter steht für einen der Buchstaben a-z oder A-Z.
\item
\gqsldigit steht für eine der Ziffern 0-9.
\item
Der gesamte Text des \gqslidentifier darf nicht ein Schlüsselwort von GQSL
sein.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Literale}

\begin{EBNF}
\item[\gqslstringliteral] \tokquote \{ \gqslstringchar\} \tokquote
\end{EBNF}

Wobei \gqslstringchar für ein von \tokquote verschiedenes Zeichen steht.
Der Typ eines \gqslstringliteral ist \tokstring.

\begin{EBNF}
\item[\gqslintliteral] [ \tokplus | \tokminus ] \gqsldigit \{ \gqsldigit\}
\end{EBNF}

Der Typ eines \gqslintliteral ist \tokinteger

\begin{EBNF}
\item[\gqslregexp] \tokbeginrequote \{ \gqslregexpchar \} \tokendrequote
\end{EBNF}

Wobei \gqslregexpchar für ein von \tokbeginrequote und \tokendrequote
und von White Space verschiedenes Zeichen steht. \{ \gqslregexpchar \}
muss ein gültiger regulärer Ausdruck sein, nach der Definition des
Ada95-Pakets GNAT.Regpat.


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Typen}
\label{language_types}

Jede \gqslexpression und jede Variable hat in GQSL einen Typ, der ihren
Wertebereich bestimmt.

\begin{EBNF}
\item[\gqsltype] \tokinteger | \tokstring | \toknodeset | \tokedgeset
                 | \toksubgraph | \tokselection
\end{EBNF}

\begin{description}
\item[\tokinteger] Ganze Zahlen in einem implemetierungsabhängigen
Bereich $min .. max$ mit $min < -16.000$ und $max > +16.000$.
Ein GQSL-Interpreter muss den genauen Wertebereich dokumentieren.
\item[\tokstring] Zeichenkette beliebiger Länge
\item[\toknodeset] Endliche Menge von IML-Knoten
\item[\tokedgeset] Endliche Menge von IML-Kanten
\item[\toksubgraph] Endliche Menge von IML-Knoten zusammen mit endlicher
Menge von IML-Kanten. Für jede enthaltene IML-Kante $e$ mit Quellknoten $v$
und Zielknoten $w$ sind stets $v$ und $w$ ebenfalls in dem
\toksubgraph enthalten. Variablen dieses Typs können IML-Teilgraphen
speichern.
\item[\tokselection] Endliche Menge von IML-Knoten zusammen mit endlicher
Menge von IML-Kanten. Variablen dieses Typs können Selektionen speichern.
\end{description}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Variablen}
\label{language_variables}

Eine \gqslquery oder ein \gqslscript kann in ihrem/seinem
\gqsldeclarationpart Variablen deklarieren. Jede dieser Variablen hat einen
definierten Typ (siehe Kapitel \ref{language_types}).

\begin{EBNF}
\item[\gqsldeclarationpart] \{ \gqsldeclaration \toksemicolon \}
\item[\gqsldeclaration] \gqslidentifier \tokcolon \gqsltype
\end{EBNF}

\begin{enumerate}
\item Wird eine \gqslquery oder ein \gqslscript aufgerufen, so werden alle
Variablen des zugehörigen \gqsldeclarationpart erzeugt. 
\item Alle diese Variablen werden zerstört wenn die Ausführung der \gqslquery
bzw. des \gqslscript endet.
\item Zu jedem Zeitpunkt der Ausführung hat jede
dieser Variablen einen Wert innerhalb des Wertebereichs ihres Typs. Der Wert
ändert sich nur durch ein \gqslassignment an die Variable.
\item Jede \gqsldeclaration deklariert genau eine Variable, die über ihren
\gqslidentifier innerhalb des \gqslquerybody bzw. des \gqslscriptbody
referenziert werden kann. Sie ist vom Typ \gqsltype.
\item Keine zwei verschiedenen \gqsldeclaration dürfen den gleichen
\gqslidentifier innerhalb des selben \gqsldeclarationpart verwenden.
\item Keine \gqsldeclaration darf
den gleichen \gqslidentifier verwenden wie eine \gqsldeclaration innerhalb
einer \gqslparameterlist, die der selben \gqslquery bzw. dem selben \gqslscript
angehört (siehe Kapitel \ref{language_parameter}).
\item Zum Zeitpunkt der Erzeugung nimmt eine Variable ihren Initialwert an.
Der Initialwert einer Variable ist implementierungsabhängig und kann nicht
explizit angegeben werden. Es dürfen
keine Annahmen über den Initialwert getroffen werden.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Parameter}
\label{language_parameter}

Eine \gqslquery oder ein \gqslscript kann Parameter deklarieren.
Jeder dieser Parameter hat einen
definierten Typ (siehe Kapitel \ref{language_types}).

\begin{EBNF}
\item[\gqslparameterlist] \gqsldeclaration
                          \{ \toksemicolon \gqsldeclaration \}
\end{EBNF}

\begin{enumerate}
\item Wird eine \gqslquery oder ein \gqslscript aufgerufen, so werden alle
Parameter erzeugt und nehmen den  durch den Aufruf spezifizierten Initialwert
an (siehe Kapitel \ref{language_query_call} bzw.
\ref{language_complexstatement}).
\item Alle Parameter werden zerstört, wenn die Ausführung der \gqslquery
bzw. des \gqslscript endet.
\item Zu jedem Zeitpunkt der Ausführung hat jeder Parameter einen Wert
innerhalb des Wertebereichs seines Typs. Der Wert eines Parameters ändert
sich nur duch ein \gqslassignment an den Parameter.
\item Jede \gqsldeclaration deklariert genau einen Parameter, der über seinen
\gqslidentifier innerhalb des \gqslquerybody bzw. des \gqslscriptbody
referenziert werden kann.
\item Keine zwei verschiedenen \gqsldeclaration dürfen den gleichen
\gqslidentifier innerhalb der selben \gqslparameterlist verwenden.
\item Keine \gqsldeclaration darf den gleichen \gqslidentifier verwenden wie
eine \gqsldeclaration innerhalb eines \gqsldeclarationpart, der zu der
selben \gqslquery bzw. dem selben \gqslscript gehört (siehe Kapitel
\ref{language_variables}).
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Query}
\label{language_queries}

\begin{EBNF}
\item[\gqslquery] ~\\
                  \tokquery \gqslidentifier \\
                  ~~ [ \tokopenbracket \gqslparameterlist \tokclosebracket ] \\
                  ~~ \tokreturn \gqsltype \tokis \\
                  ~~~ \gqsldeclarationpart \\
                  \tokbegin \\
                  ~~~ \gqslquerybody \\
                  ~~~ \tokreturn \gqslexpression \toksemicolon \\
                  \tokend \toksemicolon
\end{EBNF}

\begin{enumerate}
\item Definiert eine GQSL Query, die aus jeder anderen GQSL Query sowie aus
jedem GQSL Script durch den \gqslidentifier aufgerufen werden kann.
\item In dem \gqslquerybody und in der \gqslexpression sind alle Variablen
aus dem \gqsldeclarationpart,
alle Parameter aus der \gqslparameterlist, sowie alle dem Interpreter bekannten
GQSL Queries sichtbar. Sonst ist in dem \gqslquerybody nichts sichtbar.
\item Nach einem Aufruf werden die Parameter der Query erzeugt und nehmen
ihre Initialwerte an (siehe Kapitel \ref{language_parameter}), die
Variablen werden erzeugt (siehe Kapitel \ref{language_variables}) und
schließlich wird der \gqslquerybody ausgeführt (siehe Kapitel
\ref{language_querybody}).
\item Falls der \gqslquerybody erfolgreich ausgeführt wurde, dann wird die
\gqslexpression (siehe Kapitel \ref{language_expression}) ausgewertet.
Andernfalls ist die Ausführung der Query fehlerhaft.
\item Falls die \gqslexpression erfolgreich ausgewertet wurde, so wird ihr
Ergebnis zum Rückgabewert. Die Ausführung der Query ist erfolgreich.
Andernfalls ist die Ausführung der Query fehlerhaft.
\item Falls die Ausführung der Query erfolgreich ist, so werden ihre
Variablen und Parameter zerstört und die Ausführung der Query endet.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Script}
\label{language_scripts}

\begin{EBNF}
\item[\gqslscript] ~\\
                  \tokscript \gqslidentifier \\
                  ~~ [ \tokopenbracket \gqslparameterlist \tokclosebracket ] \\
                  ~~~ \gqsldeclarationpart \\
                  \tokbegin \\
                  ~~~ \gqslscriptbody \\
                  \tokend \toksemicolon
\end{EBNF}

\begin{enumerate}
\item Definiert ein GQSL Script, das von jedem GQSL Script durch den
\gqslidentifier aufgerufen werden kann. Das Script kann auch von einem
GQSL Interpreter direkt ausgeführt werden.
\item In dem \gqslscriptbody sind alle Variablen aus dem \gqsldeclarationpart,
alle Parameter aus der \gqslparameterlist, sowie alle dem Interpreter bekannten
GQSL Queries und GQSL Scripts sichtbar. Sonst ist in dem \gqslscriptbody
nichts sichtbar.
\item Nach einem Aufruf werden die Parameter des Scripts erzeugt und nehmen
ihren Initialwert an (siehe Kapitel \ref{language_parameter}), die
Variablen werden erzeugt (siehe Kapitel \ref{language_variables}) und
schließlich wird der \gqslscriptbody ausgeführt (siehe Kapitel
\ref{language_scriptbody}).
\item Falls der \gqslscriptbody erfolgreich ausgeführt wurde, dann ist die
Ausführung des Scripts erfolgreich. Andernfalls ist die Ausführung des Scripts
fehlerhaft.
\item Falls die Ausführung des Scripts erfolgreich ist, so werden seine
Variablen und Parameter zerstört und die Ausführung des Scripts endet.
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%
\subsubsection{Query Body}
\label{language_querybody}


\begin{EBNF}
\item[\gqslquerybody] \{ \gqslstatement \}
\end{EBNF}

\begin{enumerate}
\item Ein \gqslquerybody hat eine bestimmte \emph{Sicht}. Die Sicht ist die
Menge aller Objekte (genauer: Variablen, Parameter, Queries und Scripts),
die in dem \gqslquerybody sichtbar sind
(vgl. Kapitel \ref{language_queries}). Ein Objekt ist in dem \gqslquerybody
sichtbar, genau dann wenn es in dessen Sicht enthalten ist.
\item Alle Nicht-Terminale, die aus dem \gqslquerybody abgeleitet sind
(die in einem Ableitungsbaum unter dem Symbol \gqslquerybody angeordnet sind),
haben die selbe Sicht wie der \gqslquerybody.
\item Ein \gqslquerybody wird ausgeführt, indem alle \gqslstatement in der
Reihenfolge einer Linksableitung der Grammatik ausgeführt werden. Sobald
ein \gqslstatement fehlerhaft ausgeführt wird, stoppt die Ausführung, es
wird keines der nachfogenden \gqslstatement ausgeführt und
der \gqslquerybody ist fehlerhaft ausgeführt.
\item Der \gqslquerybody ist erfolgreich ausgeführt, falls er entweder kein
\gqslstatement enthält oder falls das letzte \gqslstatement erfolgreich
ausgeführt wurde.
\item Die Ausführung des \gqslquerybody endet sobald er entweder erfolgreich
ausgeführt ist, oder fehlerhaft ausgeführt ist.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Script Body}
\label{language_scriptbody}

\begin{EBNF}
\item[\gqslscriptbody] \{ \gqslcomplexstatement \}
\end{EBNF}

\begin{enumerate}
\item Ein \gqslscriptbody hat eine bestimmte \emph{Sicht}. Die Sicht ist die
Menge aller Objekte (genauer Variablen, Parameter, Queries und Scripts),
die in dem \gqslscriptbody sichtbar sind
(vgl. Kapitel \ref{language_scripts}). Ein Objekt ist in dem \gqslscriptbody
sichtbar, genau dann wenn es in der Sicht enthalten ist.
\item Alle Nicht-Terminale, die aus dem \gqslscriptbody abgeleitet sind
(die in einem Ableitungsbaum unter dem Symbol \gqslscriptbody angeordnet sind),
haben die selbe Sicht wie der \gqslscriptbody.
\item Ein \gqslscriptbody wird ausgeführt, indem alle \gqslcomplexstatement
in der Reihenfolge einer Linksableitung der Grammatik ausgeführt werden. Sobald
ein \gqslcomplexstatement fehlerhaft ausgeführt wird, stoppt die Ausführung,
es wird keines der nachfolgenden \gqslcomplexstatement ausgeführt und der
\gqslscriptbody ist fehlerhaft ausgeführt.
\item Der \gqslscriptbody ist erfolgreich ausgeführt, falls er entweder kein
\gqslcomplexstatement enthält oder falls das letzte \gqslcomplexstatement
erfolgreich ausgeführt wurde.
\item Die Ausführung des \gqslscriptbody endet, sobald er entweder erfolgreich
ausgeführt ist, oder fehlerhaft ausgeführt ist.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Statement}

\begin{EBNF}
\item[\gqslstatement] \gqslassignment \toksemicolon
\item[\gqslassignment] \gqslidentifier \tokequal \gqslexpression
\end{EBNF}

\begin{enumerate}
\item Der \gqslidentifier muss entweder eine sichtbare Variable oder einen
sichtbaren Parameter bezeichnen. Diese/r Variable/Parameter wird $lhs$ genannt.
\item Der Typ der \gqslexpression muss der selbe Typ sein wie der Typ von $lhs$
\item Zur Ausführung des \gqslstatement wird die \gqslexpression ausgewertet.
Falls die \gqslexpression erfolgreich ausgewertet wurde, so nimmt
$lhs$ den Wert der \gqslexpression an. In diesem Fall ist
die Ausführung des \gqslstatement erfolgreich.
\item Falls \gqslexpression fehlerhaft ausgewertet wurde, dann ist die
Ausführung des \gqslstatement fehlerhaft.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Complex Statement}
\label{language_complexstatement}

\begin{EBNF}
\item[\gqslcomplexstatement] \gqslstatement | \gqslscriptcall \toksemicolon
\item[\gqslscriptcall] \gqslidentifier [ ( \gqslargumentlist ) ]
\item[\gqslargumentlist] \gqslexpression \{ \tokcomma \gqslexpression  \}
\end{EBNF}

\begin{description}
\item[\gqslstatement] Jedes \gqslcomplexstatement enthält alle Möglichkeiten
des \gqslstatement.
  \begin{enumerate}
  \item Zum Ausführen des \gqslcomplexstatement wird das \gqslstatement
  ausgeführt.
  \item Das \gqslcomplexstatement ist erfogreich ausgeführt, falls das
  \gqslstatement erfolgreich ausgeführt ist.
  \item Das \gqslcomplexstatement ist fehlerhaft ausgeführt, falls das
  \gqslstatement fehlerhaft ausgeführt ist.
  \end{enumerate}
\item[\gqslscriptcall] Aufruf eines GQSL Scripts.
  \begin{enumerate}
  \item \gqslidentifier muss ein sichtbares GQSL Script $S$ bezeichnen.
  \item Falls $S$ keine \gqslparameterlist besitzt, so darf keine
  \gqslargumentlist angegeben sein.
  \item Falls $S$ eine \gqslparameterlist besitzt, so muss eine
  \gqslparameterlist angegeben sein und es müssen in der
  \gqslargumentlist genau so viele \gqslexpression angegeben sein, wie in der
  \gqslparameterlist \gqsldeclaration angegeben sind.
  \item Der Typ der $i$-ten \gqslexpression der \gqslargumentlist muss der
  selbe sein wie der Typ der $i$-ten \gqsldeclaration der \gqslparameterlist
  für alle $i$.
  \item Zum Ausführen des \gqslcomplexstatement werden alle \gqslexpression
  ausgewertet. Die Reihenfolge in der diese Auswirkung geschieht hat auf
  das Ergebnis keinen Einfluss. Die Reihenfolge wird durch den Interpreter
  gewählt.
  \item Falls eine der \gqslexpression fehlerhaft ausgewertet wird,
  so ist die Ausführung des \gqslcomplexstatement fehlerhaft. Andernfalls
  wird $S$ aufgerufen. Der $i$-te Parameter von $S$ nimmt den Wert der $i$-ten
  \gqslexpression an für alle $i$.
  \item Falls $S$ erfolgreich ausgeführt wurde, so ist das
  \gqslcomplexstatement erfolgreich ausgeführt. Falls $S$ fehlerhaft
  ausgeführt wurde, so ist das \gqslcomplexstatement fehlerhaft ausgeführt.
  \end{enumerate}
\end{description}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Expression}
\label{language_expression}

\begin{EBNF}
\item[\gqslexpression] ~\\
                       \gqslnodesetexpression  \\
                       | \gqsledgesetexpression \\
                       | \gqslsubgraphexpression \\
                       | \gqslselectionexpression \\
                       | \gqslvariableinspection \\
                       | \gqslquerycall \\
                       | \gqslcalculation \\
                       | \gqslliteralexpression
\end{EBNF}

Annahme: Aus den Alternativen sei die Regel mit der rechten Seite
$R$ gewählt ($R$ besteht aus genau einem Nicht-Terminal).
\begin{enumerate}
\item Der Typ der \gqslexpression ist der Typ des Nicht-Terminals $R$
(siehe die folgenden Kapitel für Details).
\item Die \gqslexpression wird erfolgreich ausgewertet, falls $R$ erfolgreich
ausgewertet wird. Andernfalls ist die \gqslexpression fehlerhaft ausgewertet.
\item Falls $R$ erfolgreich ausgewertet wird, so ist der Wert der
\gqslexpression gleich dem Wert der Auswertung von $R$.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Node Set Expression}

\begin{EBNF}
\item[\gqslnodesetexpression] \tokselect \toknodes \tokfrom \gqslexpression
                              [ \gqslnodepredicate ] \\
                             | \tokbuild \toknodes \tokfrom \gqslexpression
                              [ \tokaccept \toknodes \gqslnodepredicate ] \\
                             | \tokallnodes \\
                             | \tokrootnode
\end{EBNF}

Der Typ einer \gqslnodesetexpression ist \toknodeset.

\begin{description}
\item[select]
  Trifft eine Auswahl bestimmter IML-Knoten aus einer Menge.
  \begin{enumerate}
  \item Der Typ von \gqslexpression muss \toknodeset, \toksubgraph oder
  \tokselection sein.
  \item Die Auswertung ist erfolgreich genau dann, wenn die Auswertung der
  \gqslexpression erfolgreich ist und die Vorbereitung des \gqslnodepredicate
  erfolgreich ist falls dieses angegeben ist.
  Andernfalls ist die Auswertung fehlerhaft.
  \item Ist die Auswertung erfolgreich, dann ist das Ergebnis die größte
  Menge $M$ von IML-Knoten, so dass $\forall v \in M$
    \begin{enumerate}
    \item $v$ ist in \gqslexpression enthalten.
    \item Falls ein \gqslnodepredicate angegeben ist, dann erfüllt $v$ es
    (siehe Kapitel \ref{language_node_predicate}).
    \end{enumerate}
  \end{enumerate}
\item[build]
  Bildet eine Menge von IML-Knoten, die inzident sind zu einer gegebenen Menge
  von IML-Kanten.
  \begin{enumerate}
  \item Der Typ von \gqslexpression muss \tokedgeset sein.
  \item Die Auswertung ist erfolgreich genau dann, wenn die Auswertung von
  \gqslexpression erfolgreich ist und die Vorbereitung von \gqslnodepredicate
  erfolgreich ist, falls ein \gqslnodepredicate angegeben ist.
  Andernfalls ist die Auswertung fehlerhaft.
  \item Ist die Auswertung erfolgreich, dann ist das Ergebnis die größte
  Menge $M$ von IML-Knoten, so dass $\forall v \in M$
    \begin{enumerate}
    \item $v$ ist inzident zu einer Kante $e$ aus \gqslexpression
    \item $v$ erfüllt \gqslnodepredicate, falls dieses angegeben ist.
    \end{enumerate}
  \end{enumerate}
\item[\tokallnodes]
  Die Menge aller IML-Knoten des IML-Graphen.
  \begin{enumerate}
  \item Die Auswertung ist stets erfolgreich.
  \item Das Ergebnis ist die Menge aller IML-Knoten des IML-Graphen.
  \end{enumerate}
\item[\tokrootnode]
  Die Wurzel des IML-Graphen.
  \begin{enumerate}
  \item Die Auswertung ist stets erfolgreich.
  \item Das Ergebnis ist die Menge, die den Wurzelknoten des dem IML-Graphen
  zugrundeliegenden IML-Programms enthält und sonst nichts.
  \end{enumerate}
\end{description}



%%%%%%%%%%%%%%%%%%%%
\subsubsection{Edge Set Expression}

\begin{EBNF}
\item[\gqsledgesetexpression] \tokselect \tokedges \tokfrom \gqslexpression
                              [ \gqsledgepredicate ] \\
                             | \tokbuild \tokedges [ \tokfrom \gqslexpression ]
                                                   [ \tokto \gqslexpression ]
                                                   [ \gqsledgepredicate ]
\end{EBNF}

Der Typ einer \gqsledgesetexpression ist \tokedgeset.

\begin{description}
\item[select] Trifft eine Auswahl von bestimmten IML-Kanten aus einer Menge.
  \begin{enumerate}
  \item Der Typ von \gqslexpression muss \tokedgeset, \toksubgraph oder
  \tokselection sein.
  \item Die Auswertung ist erfolgreich genau dann, wenn die Auswertung von
  \gqslexpression erfolgreich ist und das \gqsledgepredicate entweder nicht
  angegeben ist oder seine Vorbereitung erfolgreich ist.
  Andernfalls ist die Auswertung fehlerhaft.
  \item Falls die Auswertung erfolgreich ist, dann ist das Ergebnis die
  größte Menge von IML-Kanten $M$ mit $\forall e \in M$
    \begin{enumerate}
    \item $e$ ist in der Menge der IML-Kanten aus \gqslexpression enthalten.
    \item Falls das \gqsledgepredicate angegebn ist, so wird es von $e$
    erfüllt (siehe Kapitel \ref{language_edge_predicate})
    \end{enumerate}
  \end{enumerate}
\item[build] Bildet eine Menge von IML-Kanten, die zwischen zwei Mengen
von IML-Knoten verlaufen.
  \begin{enumerate}
  \item Beide \gqslexpression müssen -- sofern sie angegeben sind -- den
  Typ \toknodeset haben.
  \item Die Auswertung ist erfolgreich, falls alle angegebenen
  \gqslexpression erfolgreich ausgewertet werden und das \gqsledgepredicate
  entweder nicht angegebn ist oder erfolgreich vorbereitet wird. Andernfalls
  ist die Auswertung fehlerhaft.
  \item Das Ergebnis ist die Menge $M$ aller IML-Kanten mit $\forall
  e \in M$
    \begin{enumerate}
    \item $e$ ist im IML-Graph enthalten.
    \item Der Start-Knoten von $e$ ist in der \tokfrom-\gqslexpression
    enthalten, falls \tokfrom-\gqslexpression angegeben ist.
    \item Der Ziel-Knoten von $e$ ist in der \tokto-\gqslexpression
    enthalten, falls \tokto-\gqslexpression angegeben ist.
    \item $e$ erfüllt das \gqsledgepredicate falls dieses angegeben ist.
    \end{enumerate}
  \end{enumerate}
\end{description}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Subgraph Expression}

\begin{EBNF}
\item[\gqslsubgraphexpression] \tokmake \tokgraph \tokopenbracket
                                    \gqslexpression \tokcomma \gqslexpression
                                    \tokclosebracket \\
                               | \tokbuild \tokgraph \tokbased \tokon
                                    \gqslexpression \tokfollow \tokedges
                                    \gqsledgepredicate
                                    [ \tokaccept \toknodes \gqslnodepredicate ]
                                    [ \tokuntil \tokdepth \gqslexpression ]
\end{EBNF}

Der Typ einer \gqslsubgraphexpression ist immer \toksubgraph.

\begin{description}
\item[make] Erstellt einen IML-Teilgraph aus einer Menge von Knoten und einer
Menge von Kanten.
  \begin{enumerate}
  \item Der Typ der ersten \gqslexpression muss \toknodeset sein.
  \item Der Typ der zweiten \gqslexpression muss \tokedgeset sein.
  \item Die Auswertung ist erfolgreich genau dann, wenn die Auswertung beider
  \gqslexpression erfolgreich ist. Andernfalls ist die Auswertung fehlerhaft.
  \item Falls die Auswertung erfolgreich ist, so ist das Ergebnis ein
  IML-Teilgraph mit allen IML-Knoten der ersten
  \gqslexpression sowie denjenigen IML-Kanten die in der zweiten
  \gqslexpression enthalten sind und deren Start- und Zielknoten in der
  ersten \gqslexpression enthalten sind.
  \end{enumerate}
\item[build] Fragt einen Teilgraph an, ausgehend von einer Grundmenge von
IML-Knoten.
  \begin{enumerate}
  \item Der Typ der ersten \gqslexpression muss \toknodeset sein.
  \item Falls die zweite \gqslexpression angegeben ist, so muss ihr Typ
  \tokinteger sein.
  \item Die Auswertung ist erfolgreich falls die folgenden Bedingungen
  erfüllt sind:
    \begin{enumerate}
    \item Alle \gqslexpression werden erfolgreich ausgewertet.
    \item Die Vorbereitung des \gqsledgepredicate muss erfolgreich sein.
    \item Die Vorbereitung des \gqslnodepredicate muss erfolgreich sein,
    falls es angegeben ist.
    \item Falls die zweite \gqslexpression angegeben ist, so muss ihr Wert
    größer oder gleich 0 sein.
    \end{enumerate}
  andernfalls ist die Auswertung fehlerhaft.
  \item Der Wert ergibt sich durch eine Breitensuche auf dem IML-Graph.
  Begonnen wird mit der IML-Knotenmenge, die durch die erste \gqslexpression
  gegeben ist (Ebene 0). Dann werden alle IML-Kanten verfolgt für die
    \begin{enumerate}
    \item Das \gqsledgepredicate erfüllt ist.
    \item Der über diese IML-Kante erreichte IML-Knoten das \gqslnodepredicate
    erfüllt, sofern dieses angegeben ist.
    \item Die Nummer der Ebene kleiner ist als die zweite \gqslexpression,
    sofern diese angegeben ist.
    \end{enumerate}
  Wurde eine IML-Kante verfolgt, so wird sie zum Ergebnis hinzugefügt. Der
  erreichte IML-Knoten wird ebenfalls zum Ergebnis hinzugefügt. Die Menge
  aller so erreichten IML-Knoten bildet die Ausgangsmenge für den nächsten
  Schritt. Sie ist eine Ebene tiefer. Die Suche bricht ab, wenn keine neuen
  Kanten mehr aufgenommen werden.
  \end{enumerate}
\end{description}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Selection Expression}

\begin{EBNF}
\item[\gqslselectionexpression] \tokmake \tokselection \tokopenbracket
                                   \gqslexpression \tokcomma \gqslexpression
                                   \tokclosebracket
\end{EBNF}

\begin{enumerate}
\item die erste \gqslexpression muss den Typ \toknodeset haben.
\item die zweite \gqslexpression muss den Typ \tokedgeset haben.
\item Der Typ der \gqslselectionexpression ist \tokselection.
\item Die Auswertung ist erfolgreich genau dann, wenn die Auswertung beider
\gqslexpression erfolgreich ist. Andernfalls ist die Auswertung fehlerhaft.
\item Falls die Auswertung erfolgreich ist, dann ist der Wert die Selektion,
die alle IML-Knoten und alle IML-Kanten aus den beiden \gqslexpression und
sonst nichts enthält.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Variable Inspection}

\begin{EBNF}
\item[\gqslvariableinspection] \gqslidentifier
\end{EBNF}

\begin{enumerate}
\item Der \gqslidentifier muss entweder eine sichtbare Variable $v$ oder einen
sichtbaren Parameter $p$ bezeichnen.
\item Der Typ der \gqslvariableinspection ist der Typ von $v$ bzw. $p$.
\item Eine \gqslvariableinspection wird stets erfolgreich ausgewertet.
\item Der Wert der \gqslvariableinspection ist der Wert, den $v$ bzw. $p$
zum Zeitpunkt
der Auswertung hat.
\end{enumerate}

\begin{description}
\item[Anmerkung] Eine \gqslvariableinspection kann nur während der Lebenszeit
einer Variable bzw. eines Parameters geschehen. Eine Variable hat zu jedem
Zeitpunkt ihrer Lebenszeit einen Wert. (vgl. Kapitel \ref{language_variables},
\ref{language_parameter})
\item[Anmerkung] Der Wert von $v$ verändert sich durch die
\gqslvariableinspection nicht.
\end{description}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Query Call}
\label{language_query_call}

\begin{EBNF}
\item[\gqslquerycall] \gqslidentifier [ \tokopenbracket \gqslargumentlist
                                        \tokclosebracket ]
\end{EBNF}

Anmerkung: \gqslargumentlist siehe \ref{language_complexstatement}

\begin{enumerate}
\item \gqslidentifier muss eine sichtbare GQSL Query $Q$ bezeichnen.
\item Falls $Q$ keine \gqslparameterlist besitzt, so darf keine
\gqslargumentlist angegeben sein.
\item Falls $Q$ eine \gqslparameterlist besitzt, so muss eine
\gqslargumentlist angegeben sein und darin müssen genau so viele
\gqslexpression angegeben sein, wie in der
\gqslparameterlist \gqsldeclaration angegeben sind.
\item Der Typ der $i$-ten \gqslexpression der \gqslargumentlist muss
der selbe sein wie der Typ der $i$-ten \gqsldeclaration der
\gqslparameterlist für alle $i$.
\item Der Typ des \gqslquerycall ist der Typ des Rückgabewerts von $Q$.
\item Zum Auswerten des \gqslquerycall werden alle \gqslexpression
in durch den Interpreter willkürlich bestimmter Reihenfolge ausgewertet.
\item Falls eine der \gqslexpression fehlerhaft ausgewertet wird,
so ist die Auswertung des \gqslquerycall fehlerhaft. Andernfalls
wird $Q$ aufgerufen. Der $i$-te Parameter nimmt den Wert der $i$-ten
\gqslexpression an für alle $i$.
\item Falls $Q$ erfolgreich ausgeführt wurde, so ist der
\gqslquerycall erfolgreich ausgewertet. Falls $Q$ fehlerhaft
ausgeführt wurde, so ist der \gqslquerycall fehlerhaft ausgewertet.
\item Falls der \gqslquerycall erfolgreich ausgewertet wurde, so ist
sein Wert gleich dem Rückgabewert von $Q$.
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%
\subsubsection{Calculation}

\begin{EBNF}
\item[\gqslcalculation] \tokopenbracket \gqslexpression \tokclosebracket \\
                       | \gqslexpression \tokplus \gqslexpression \\
                       | \gqslexpression \tokminus \gqslexpression \\
                       | \gqslexpression \tokintersect \gqslexpression
\end{EBNF}

\begin{enumerate}
\item Der Typ aller \gqslexpression muss der selbe sein.
\item \textbf{Hinweis}: nicht alle Typen sind für jede rechte Seite der
Regel legal. Details werden in Punkt \ref{language_calc_validity} dieser
Aufzählung spezifiziert.
\item Der Typ der \gqslcalculation ist der selbe Typ wie der der
\gqslexpression.
\item Die \gqslcalculation wird erfolgreich ausgewertet genau dann alle
\gqslexpression erfolgreich ausgewertet werden und keine Einschränkung aus
Punkt \ref{language_calc_validity} zutrifft. Sonst ist sie fehlerhaft
ausgewertet.
\item Die Operatoren \tokplus, \tokminus, \tokintersect haben alle eine
gleich hohe Priorität. In einer Kette mehrerer \gqslcalculation dieser
Operatoren erfolgt die Auswertung von links nach rechts.
\item Die rechte Seite \tokopenbracket ... \tokclosebracket wird zur
Veränderung der Auswertungsreihenfolge verwendet.
\item \label{language_calc_validity} Gültigkeit und Wert in Abhängigkeit von
der gewählten Regel:
  \begin{description}
  \item[\tokopenbracket\tokclosebracket] \begin{enumerate}
                    \item Es ist jeder Typ zulässig.
                    \item Der Wert ist der Wert der \gqslexpression.
                    \end{enumerate}
  \item[\tokplus]   Es ist jeder Typ zulässig. Der Wert ist abhängig vom
                    verwendeten Typ:
                    \begin{description}
                    \item[\tokinteger] Summe der \gqslexpression. Falls
                    die Summe den (implementationsabhängigen) Wertebereich
                    des Typs \tokinteger verlässt, so ist die \gqslcalculation
                    fehlerhaft ausgewertet.
                    \item[\tokstring] Konkatenation der \gqslexpression.
                    \item[\toknodeset, \tokedgeset] Vereinigung der
                    \gqslexpression.
                    \item[\toksubgraph, \tokselection]
                    Alle IML-Knoten aus beiden \gqslexpression mit allen
                    IML-Kanten aus beiden \gqslexpression.
                    \end{description}
  \item[\tokminus]  Es sind alle Typen außer \tokstring zugelassen. Der Wert
                    ist abhängig vom verwendeten Typ:
                    \begin{description}
                    \item[\tokinteger] Differenz der \gqslexpression. Falls
                    die Differenz den (implementationsabhängigen) Wertebereich
                    verlässt, so ist die \gqslcalculation fehlerhaft
                    ausgewertet.
                    \item[\tokstring] Illegal.
                    \item[\toknodeset, \tokedgeset] Mengendifferenz der
                    \gqslexpression.
                    \item[\toksubgraph] Menge der IML-Knoten ist die Differenz
                    der IML-Knoten-Mengen der \gqslexpression. Menge der
                    IML-Kanten ist die größte Teilmenge der Differenz der
                    IML-Kanten-Mengen, so dass der Start- und Zielknoten jeder
                    Kante in der Differenz der IML-Knoten-Mengen enthalten ist.
                    \item[\tokselection] Differenz der IML-Knoten-Mengen und
                    Differenz der IML-Kanten-Mengen.
                    \end{description}
  \item[\tokintersect] Die Typen \tokinteger und \tokstring sind nicht
                    zugelassen. Der Wert ist abhängig vom angegebenen Typ:
                    \begin{description}
                    \item[\tokinteger, \tokstring] Illegal.
                    \item[\toknodeset, \tokedgeset] Mengenschnitt der
                    \gqslexpression
                    \item[\toknodeset, \tokedgeset] Menge der IML-Knoten ist
                    Schnittmenge der IML-Knoten-Mengen der \gqslexpression.
                    Menge der IML-Kanten ist Schnittmenge der \gqslexpression.
                    \end{description}
  \end{description}
\end{enumerate}



%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Literal Expression}

\begin{EBNF}
\item[\gqslliteralexpression] \gqslintliteral \\
                       | \gqslstringliteral
\end{EBNF}

Eine \gqslliteralexpression wird stets erfolgreich ausgewertet.
\begin{description}
\item[\gqslintliteral] Der Typ der \gqslliteralexpression ist \tokinteger.
Der Wert der \gqslliteralexpression ist die Interpretation der
Ableitung des \gqslintliteral im 10er Zahlensystem. Falls dieser Wert den
(implementationsabhängigen) Wertebereich überschreitet, so ist die
\gqslliteralexpression nicht zulässig.
\item[\gqslstringliteral] Der Typ der \gqslliteralexpression ist \tokstring.
Der Wert der \gqslliteralexpression ist die Ableitung
des \gqslstringliteral.
\end{description}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Logik}

\begin{EBNF}
\label{language_node_predicate}
\item[\gqslnodepredicate] \gqslnodechoosingproduct
                            [ \tokor \gqslnodepredicate ]
\label{language_edge_predicate}
\item[\gqsledgepredicate] \gqsledgechoosingproduct
                            [ \tokor \gqsledgepredicate ]
\item[\gqslattribexpr] \gqslattribproduct [ \tokor \gqslattribexpr ]
\end{EBNF}

\begin{enumerate}
\item  Das \gqslnodepredicate bzw. das \gqsledgepredicate bzw. die
\gqslattribexpr wird erfolgreich vorbereitet, falls auf der rechten Seite
der Regel sowohl das
\gqslnodechoosingproduct bzw. das
\gqsledgechoosingproduct bzw. das \gqslattribproduct und (falls angegeben) das
\gqslnodepredicate bzw. das \gqsledgepredicate bzw. die \gqslattribexpr
erfolgreich vorbereitet werden. Andernfalls wird fehlerhaft vorbereitet.
\item Das \gqslnodepredicate bzw. das \gqsledgepredicate bzw. die
\gqslattribexpr wird erfüllt dann und nur dann, falls
das \gqslnodechoosingproduct bzw. das \gqsledgechoosingproduct bzw.
das \gqslattribproduct oder auf der rechten Seite der Regel das
\gqslnodepredicate bzw. das \gqsledgepredicate bzw. die \gqslattribexpr
angegeben ist und erfüllt wird.
\end{enumerate}

%%%%
\begin{EBNF}
\item[\gqslnodechoosingproduct] \gqslnodechoosingstatement [ \tokand
                                \gqslnodechoosingproduct ]
\item[\gqsledgechoosingproduct] \gqsledgechoosingstatement [ \tokand
                                \gqsledgechoosingproduct ]
\item[\gqslattribproduct] \gqslattribstatement [ \tokand \gqslattribproduct ]
\end{EBNF}

\begin{enumerate}
\item Das \gqslnodechoosingproduct bzw. das \gqsledgechoosingproduct bzw.
das \gqslattribproduct wird
erfolgreich vorbereitet, falls auf der rechten Seite das
\gqslnodechoosingstatement bzw. das \gqsledgechoosingstatement bzw. das
\gqslattribstatement und (falls angegeben) das 
\gqslnodechoosingproduct bzw. das \gqsledgechoosingproduct bzw. das
\gqslattribproduct erfolgreich
vorbereitet werden. Andernfalls ist die Vorbereitung fehlerhaft.
\item Das \gqslnodechoosingproduct bzw. das \gqsledgechoosingproduct bzw.
das \gqslattribproduct wird
erfüllt genau dann, falls das \gqslnodechoosingstatement bzw. das
\gqsledgechoosingstatement bzw. das \gqslattribstatement und auf der rechten
Seite das \gqslnodechoosingproduct bzw. das \gqsledgechoosingproduct
bzw. das \gqslattribproduct nicht angegeben
ist oder erfüllt wird.
\end{enumerate}

%%%%
\begin{EBNF}
\item[\gqslnodechoosingstatement] \tokopenbracket \gqslnodepredicate
                                  \tokclosebracket \\
                                  | \toknot \gqslnodechoosingstatement \\
                                  | \gqslsimplenodechoice
\item[\gqsledgechoosingstatement] \tokopenbracket \gqsledgepredicate
                                  \tokclosebracket \\
                                  | \toknot \gqsledgechoosingstatement \\
                                  | \gqslsimpleedgechoice
\item[\gqslattribstatement] \tokopenbracket \gqslattribexpr \tokclosebracket \\
                            | \toknot \gqslattribstatement \\
                            | \gqslsimpleattribstatement
\end{EBNF}

\begin{description}
\item[Klammerung] Wird verwendet, um die Auswertungsreihenfolge zu
beeinflussen.
  \begin{enumerate}
  \item Das \gqslnodechoosingstatement bzw. das \gqsledgechoosingstatement
  bzw. das \gqslattribstatement wird erfolgreich vorbereitet, falls auf der
  rechten Seite das \gqslnodepredicate bzw. das \gqsledgepredicate bzw. die
  \gqslattribexpr erfolgreich vorbereitet wird. Andernfalls ist die
  Vorbereitung fehlerhaft.
  \item Das \gqslnodechoosingstatement bzw. das \gqsledgechoosingstatement
  bzw. das \gqslattribstatement wird erfüllt genau dann, falls das
  \gqslnodepredicate bzw. das \gqsledgepredicate bzw. die \gqslattribexpr
  erfüllt wird.
  \end{enumerate}
\item[Negation] Logische Negation.
  \begin{enumerate}
  \item Das \gqslnodechoosingstatement bzw. das \gqsledgechoosingstatement
  bzw. das \gqslattribstatement wird erfolgreich vorbereitet, falls auf der
  rechten Seite das \gqslnodechoosingstatement bzw. das
  \gqsledgechoosingstatement bzw. das
  \gqslattribstatement erfolgreich vorbereitet wird. Andernfalls ist die
  Vorbereitung fehlerhaft.
  \item Das \gqslnodechoosingstatement bzw. das \gqsledgechoosingstatement
  bzw. das \gqslattribstatement wird erfüllt genau dann, falls auf der
  rechten Seite das \gqslnodechoosingstatement bzw. das
  \gqsledgechoosingstatement bzw. das \gqslattribstatement nicht erfüllt wird.
  \end{enumerate}
\item[Simple Statement] Logische Aussage.
  \begin{enumerate}
  \item Das \gqslnodechoosingstatement bzw. das \gqsledgechoosingstatement
  bzw. das \gqslattribstatement wird erfolgreich vorbereitet, falls auf der
  rechten Seite der \gqslsimplenodechoice bzw. der \gqslsimpleedgechoice bzw.
  das \gqslsimpleattribstatement erfolgreich vorbereitet wird.
  Andernfalls ist die Vorbereitung fehlerhaft.
  \item Das \gqslnodechoosingstatement bzw. das \gqsledgechoosingstatement
  bzw. das \gqslattribstatement wird erfüllt genau dann, falls der
  \gqslsimplenodechoice bzw. der \gqslsimpleedgechoice bzw. das
  \gqslsimpleattribstatement
  erfüllt wird.
  \end{enumerate}
\end{description}

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Simple Node Choice}

\begin{EBNF}
\item[\gqslsimplenodechoice] \tokhaving
                          \tokopenbracket \gqslattribexpr \tokclosebracket
                            | \toktype \gqslregexp
\end{EBNF}

\begin{description}
\item[\tokhaving] Testet ob die Attribute eines IML-Knoten einen bestimmten
logischen Ausdruck erfüllen.
  \begin{enumerate}
  \item Die Vorbereitung ist erfolgreich genau dann, wenn die
  Vorbereitung der \gqslattribexpr erfolgreich ist. Andernfalls ist die
  Vorbereitung fehlerhaft.
  \item Der \gqslsimplenodechoice wird erfüllt genau dann, wenn die
  \gqslattribexpr erfüllt wird. Andernfalls wird der \gqslsimplenodechoice
  nicht erfüllt.
  \end{enumerate}
\item[\toktype] Testet ob ein IML-Knoten einen bestimmten Typ hat.
  \begin{enumerate}
  \item Die Vorbereitung ist erfolgreich.
  \item Der \gqslsimplenodechoice wird erfüllt von einem IML-Knoten $N$,
  falls der Name des Typs von $N$ in der Sprache von \gqslregexp enthalten ist.
  Andernfalls wird der \gqslsimplenodechoice nicht erfüllt.
  \end{enumerate}
\end{description}

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Simple Edge Choice}

\begin{EBNF}
\item[\gqslsimpleedgechoice] \toktype \gqslregexp
\end{EBNF}

\begin{enumerate}
\item Die Vorbereitung ist erfolgreich.
\item Der \gqslsimpleedgechoice wird erfüllt von einer IML-Kante $E$, falls der
Name des Typs von $E$ in der Sprache von \gqslregexp enthalten ist.
Andernfalls wird der \gqslsimpleedgechoice nicht erfüllt.
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%
\subsubsection{Atomic Attribute Values}

Die Eine Attributinspektion wird auf einen einzelnen IML-Knoten $N$
angewendet. Sie hat als Ergebnis den Wert eines bestimmten Attributs
dieses IML-Knotens. Der Typ einer Attributinspektion kann nicht statisch
bestimmt werden.

\begin{EBNF}
\item[\gqslattribatomicvalue] \gqslatomicvalue | \gqslatomicstringlist
                            | \gqslatomicsloc
                            | \gqslatomictargettype | \gqslatomiclinktarget
                            | \gqslatomicsize | \gqslatomiclistchoice
\end{EBNF}

Das Nicht-Terminal \gqslattribatomicvalue ist eine Zusammenfassung aller
möglichen Attributinspektionen. Das rechts stehende Nicht-Terminal bestimmt
die Semantik der Inspektion.

\begin{EBNF}
\item[\gqslatomicvalue] \gqslidentifier
\end{EBNF}

\begin{enumerate}
\item Die Auswertung ist erfolgreich, falls $N$ ein einfaches Attribut $a$ mit
Namen \gqslidentifier besitzt und der Typ dieses Attributs Boolean oder
Natural ist. Andernfalls ist die Auswertung fehlerhaft.
\item Falls die Auswertung erfolgreich ist, dann ist der Typ des
\gqslatomicvalue gleich dem Typ von $a$.
\item Falls die Auswertung erfolgreich ist, dann ist der Wert des
\gqslatomicvalue der Wert des Attributs $a$.
\end{enumerate}

\begin{EBNF}
\item[\gqslatomicstringlist] \gqslidentifier \tokopenbracket \gqslexpression
                              \tokclosebracket
\end{EBNF}

\begin{enumerate}
\item Die Auswertung ist erfolgreich, falls
  \begin{enumerate}
  \item $N$ ein Einfaches Attribut $a$ mit Namen \gqslidentifier besitzt.
  \item Falls der Typ von $a$ Folge von Strings ist.
  \item Falls der Typ der \gqslexpression \tokinteger ist.
  \item Falls die \gqslexpression erfolgreich ausgewertet wird.
  \item Falls der Wert $i$ der \gqslexpression im Bereich $1 \leq i \leq max$
  ist, wenn $max$ die Anzahl der Folgenglieder in $a$ ist.
  \end{enumerate}
  Andernfalls ist die Auswertung fehlerhaft.
\item Der Typ ist String.
\item Falls die Auswertung erfolgreich ist, so ist der Wert der
\gqslexpression-te String von $a$.
\end{enumerate}

\begin{EBNF}
\item[\gqslatomicsloc] \gqslidentifier \tokdot
                        ( \tokline | \tokcolumn | \tokfilename | \tokpath )
\end{EBNF}

\begin{enumerate}
\item Die Auswertung ist erfolgreich genau dann, wenn $N$ ein Attribut $a$
besitzt mit Namen \gqslidentifier und Typ Source Location. Sonst ist die
Auswertung fehlerhaft.
\item Falls die Auswertung erfolgreich ist, so ist der Typ Natural, falls
die Regel nach \tokline oder \tokcolumn abgeleitet wurde. Andernfalls
ist der Typ String.
\item Falls die Auswertung erfolgreich war, dann ist der Wert:
  \begin{description}
  \item[\tokline] Die Zeilennummer von $a$
  \item[\tokcolumn] Die Spaltennummer von $a$
  \item[\tokfilename] Der Dateiname von $a$
  \item[\tokpath] Der Pfad von $a$
  \end{description}
\end{enumerate}

\begin{EBNF}
\item[\gqslatomictargettype] \gqslidentifier \tokdot \toktargettype
\end{EBNF}

\begin{enumerate}
\item Die Auswertung ist erfolgreich, falls $N$ ein
Genutztes Verweis-Attribut $a_g$, ein Ungenutztes Verweis-Attribut $a_u$, ein
Verweismengen-Attribut $a_m$ oder ein Verweisfolgen-Attribut $a_f$ mit Namen
\gqslidentifier besitzt. Sonst ist die Auswertung fehlerhaft.
\item Der Typ ist String.
\item Falls die Auswertung erfolgreich ist, so ist der Wert der Name des
Typs von IML-Knoten auf den $a_g$ verweist bzw. auf den $a_u$ verweisen
könnte bzw. auf den ein Genutzter Verweis in $a_m$ verweist bzw. auf den
ein Genutzter Verweis in $a_f$ verweist.
\end{enumerate}

\begin{EBNF}
\item[\gqslatomiclinktarget] \gqslidentifier \tokdot \gqslattribatomicvalue
\end{EBNF}

\begin{enumerate}
\item Besitzt $N$ ein Genutztes Verweis-Attribut $a$ mit Namen \gqslidentifier,
und verweist $a$ auf den IML-Knoten $M$, so wird \gqslattribatomicvalue auf
$M$ ausgewertet.
\item Die Auswertung ist erfolgreich, falls $a$ existiert und falls die
Auswertung von \gqslattribatomicvalue auf $M$ erfolgreich ist.
Sonst ist die Auswertung fehlerhaft.
\item Falls $a$ existiert, so ist der Typ der Typ der Auswertung von
\gqslattribatomicvalue auf $M$.
\item Falls die Auswertung erfolgreich ist, so ist der Wert der Wert der
Auswertung von \gqslattribatomicvalue auf $M$.
\end{enumerate}

\begin{EBNF}
\item[\gqslatomicsize] \gqslidentifier \tokdot \toksize
\end{EBNF}

\begin{enumerate}
\item Die Auswertung ist erfolgreich, falls $N$ ein Verweisfolgen-Attribut
$a_f$ oder ein Verweismengen-Attribut $a_m$ mit Namen \gqslidentifier besitzt.
Andernfalls ist die Auswertung fehlerhaft.
\item Der Typ ist Natural.
\item Falls die Auswertung erfolgreich ist, so ist der Wert die Kardinalität
von $a_m$ bzw. die Anzahl der Folgenglieder von $a_f$.
\end{enumerate}

\begin{EBNF}
\item[\gqslatomiclistchoice] \gqslidentifier \tokopenbracket \gqslexpression
                              \tokclosebracket \tokdot \gqslattribatomicvalue
\end{EBNF}

\begin{enumerate}
\item Die Auswertung ist erfolgreich, falls
  \begin{enumerate}
  \item $N$ ein Verweisfolgen-Attribut $a$ mit Namen \gqslidentifier besitzt.
  \item Falls der Typ der \gqslexpression \tokinteger ist.
  \item Falls die \gqslexpression erfolgreich ausgewertet wird.
  \item Falls der Wert $i$ der \gqslexpression im Bereich $1 \leq i \leq max$
  ist, wenn $max$ die Anzahl der Folgenglieder in $a$ ist.
  \end{enumerate}
  Andernfalls ist die Auswertung fehlerhaft.
\item Falls die Auswertung erfolgreich ist, so sei $M$ der IML-Knoten auf
den das $i$-te Folgenglied in $a$ verweist. Es wird \gqslattribatomicvalue
auf $M$ ausgewertet.
\item Falls die Auswertung erfolgreich ist, so ist der Typ der Typ von
\gqslattribatomicvalue ausgewertet auf $M$.
\item Falls die Auswertung erfolgreich ist, so ist der Wert der Wert der
Auswertung von \gqslattribatomicvalue ausgewertet auf $M$.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%
\subsubsection{Simple Attribute Statement}

\begin{EBNF}
\item[\gqslsimpleattribstatement] \gqslattribatomicvalue [ \gqslcompop 
                                                              \gqslexpression ]
\item[\gqslcompop] \toksmaller | \tokequal | \tokgreater | \toksmallerequal
                  | \tokgreaterequal | \tokdifferent
\end{EBNF}

\begin{enumerate}
\item Das \gqslsimpleattribstatement wird erfolgreich vorbereitet, falls
die \gqslexpression entweder nicht angegeben ist oder erfolgreich ausgewertet
wird.
Andernfalls wird das \gqslsimpleattribstatement fehlerhaft vorbereitet.
\item Es sind nur die nachfolgend genannten Kombinationen der Typen von
\gqslattribatomicvalue, \gqslexpression und des \gqslcompop zulässig:
  \begin{description}
  \item[Boolean, ---] Es darf kein \gqslcompop und keine \gqslexpression
  angegeben sein. Das \gqslsimpleattribstatement wird erfüllt, falls das
  \gqslattribatomicvalue erfolgreich ausgewertet wird und den Wert true hat.
  Sonst wird das \gqslsimpleattribstatement nicht erfüllt.
  \item[Natural, \tokinteger] Zulässig sind alle Möglichkeiten für \gqslcompop.
  Das \gqslsimpleattribstatement wird erfüllt, falls der
  \gqslattribatomicvalue erfolgreich ausgewertet wird und der entstehende
  Ausdruck nach der  mathematischen Definition korrekt ist.
  \item[String, \tokstring] Zulässig sind alle Möglichkeiten für \gqslcompop.
  Das \gqslsimpleattribstatement wird erfüllt, falls das
  \gqslattribatomicvalue erfolgreich ausgewertet wird und der entstehende
  Ausdruck korrekt ist. Eine Zeichenfolge $a$ gilt als kleiner als eine
  Zeichenfolge $b$, falls $a$ lexikographisch vor $b$ kommt.
  \end{description}
\end{enumerate}

\begin{EBNF}
\item[\gqslsimpleattribstatement] \gqslattribatomicvalue \tokin \gqslregexp
\end{EBNF}

\begin{enumerate}
\item Das \gqslsimpleattribstatement wird stets erfolgreich vorbereitet.
\item Das \gqslsimpleattribstatement wird erfüllt, falls das
\gqslattribatomicvalue erfolgreich ausgewertet wird und in der durch
\gqslregexp gegebenen Sprache enthalten ist. Andernfalls wird
\gqslsimpleattribstatement nicht erfüllt.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{GQSL vordefinierte Sprachumgebung}
\label{language_gqsl_predef_env}

\paragraph{Vordefinierte Queries}

\begin{verbatim}
Get_Current_Window
  return string is
// ... implementation defined ...
\end{verbatim}

Liefert als Ergebnis den Namen des Anzeigefensters, in dessen Kontext
der GQSL Interpreter sich befindet. Befindet sich der GQSL Interpreter
nicht im Kontext eines Anzeigefensters, so wird die Query fehlerhaft
ausgeführt.

\begin{verbatim}
Get_Current_Selection
  (Window_Name : string)
  return selection is
// ... implementation defined ...
\end{verbatim}

Erhält als Argument den Namen eines Anzeigefensters und liefert als
Ergebnis die aktuelle Selektion in diesem Anzeigefenster.
Existiert kein Anzeigefenster des übergebenen Namens, so wird die Query
fehlerhaft ausgeführt.

\begin{verbatim}
Get_Selection
  (Window_Name    : string;
   Selection_Name : string)
  return selection is
// ... implementation defined ...
\end{verbatim}

Erhält als erstes Argument den Namen eines Anzeigefensters, als zweites
Argument den Namen einer Selektion in diesem Anzeigefenster. Liefert als
Ergebnis die durch diese Namen gewählte Selektion. Existiert kein
Anzeigefenster des gewählten Namens oder existiert in dem Anzeigefenster
keine Selektion des gewählten Namens, so wird die Query fehlerhaft ausgeführt.

\begin{verbatim}
Get_Subgraph
  (Subgraph_Name : string)
  return subgraph is
// ... implementation defined ...
\end{verbatim}

Erhält als Argument den Namen eines IML-Teilgraphen. Liefert als Ergebnis
den IML-Teilgraphen des gewählten Namens. Existiert kein IML-Teilgraph
dieses Namens, so wird die Query fehlerhaft ausgeführt.

\paragraph{Vordefinierte Scripts}

\begin{verbatim}
Create_Window
  (Window_Name : string;
   Layout_Algo : string;
   Content     : subgraph) is
// ... implementation defined ...
\end{verbatim}

Erzeugt ein neues Anzeigefenster mit dem Namen \texttt{Window\_Name}.
Wendet den Layout-Algorithmus \texttt{Layout\_Algo} auf \texttt{Content}
an und fügt die so erzeugte neue Selektion in das neue Anzeigefenster ein.

Falls \texttt{Window\_Name} keinen gültigen Namen für ein Anzeigefenster
enthält oder falls bereits ein Anzeigefenster dieses Namens existiert,
so ist die Ausführung dieses Scripts fehlerhaft. Falls
\texttt{Layout\_Algo} kein gültiger Layout-Algorithmus ist, so ist die
Ausführung dieses Scripts fehlerhaft.

\begin{verbatim}
Insert_Into_Window
  (Window_Name : string;
   Layout_Algo : string;
   New_Content : subgraph) is
// ... implementation defined ...
\end{verbatim}

Wendet den Layout-Algorithmus \texttt{Layout\_Algo} auf \texttt{Content}
an und fügt die so erzeugte neue Selektion in das Anzeigefenster mit
dem Namen \texttt{Window\_Name} ein.

Falls kein Anzeigefenster des Namens \texttt{Window\_Name} existiert,
so ist die Ausführung dieses Scripts fehlerhaft. Falls
\texttt{Layout\_Algo} kein gültiger Layout-Algorithmus ist, so ist die
Ausführung dieses Scripts fehlerhaft.

\begin{verbatim}
Set_Selection
  (Window_Name    : string;
   Selection_Name : string;
   Value          : selection) is
// ... implementation definded ...
\end{verbatim}

Falls in dem Anzeigefenster \texttt{Window\_Name} noch keine Selektion mit
Name \texttt{Selection\_Name} existiert, dann erzeugt diese Selektion. Setzt
den Inhalt der Selektion mit Name \texttt{Selection\_Name} im Anzeigefenster
\texttt{Window\_Name} auf \texttt{Value}.

Falls kein Anzeigefenster mit Name \texttt{Window\_Name} existiert oder falls
\texttt{Selection\_Name} kein gültiger Name für Selektionen ist,
so ist die Ausführung dieses Scripts fehlerhaft.

\begin{verbatim}
Set_Subgraph
  (Subgraph_Name : string;
   Value         : subgraph) is
// ... implementation defined ...
\end{verbatim}

Falls noch kein IML-Teilgraph mit Name \texttt{Subgraph\_Name}
existiert, dann erzeugt diesen IML-Teilgraphen. Setzt den Inhalt
des IML-Teilgraphen mit Name \texttt{Subgraph\_Name} auf \texttt{Value}.

Falls \texttt{Subgraph\_Name} kein gültiger Name für IML-Teilgraphen ist,
so ist die Ausführung dieses Scripts fehlerhaft.
