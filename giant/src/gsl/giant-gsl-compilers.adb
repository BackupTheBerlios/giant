------------------------------------------------------------------------------
-- GIANT - Graphical IML Analysis and Navigation Tool
--
-- Copyright (C) 2003 Philipp Haeuser, Steffen Keul, Oliver Kopp,
-- Steffen Pingel, Gerrit Schulz and Martin Schwienbacher.
--
-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 2 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
--
-- First Author: Gerrit Schulz
--
-- $RCSfile: giant-gsl-compilers.adb,v $
-- $Author: schulzgt $
-- $Date: 2003/06/30 16:04:49 $
--
-- Back-End of the Gsl compiler. Uses the syntax tree generated by the 
-- Gsl parser to generate stack code for the Gsl interpreter.
-- The Ayacc grammar for the parser and the generated code is located in the 
-- subdirectory /generated.
--

------------------------------------------------------------------------------
-- packages from Bauhaus Reuse
with String_Hash;

------------------------------------------------------------------------------
-- packages from Giant
with Giant.Default_Logger;
with Giant.Parser;
with Giant.Scanner.IO;
with Giant.Gsl.Syntax_Tree;
use  Giant.Gsl.Syntax_Tree;

package body Giant.Gsl.Compilers is

   ---------------------------------------------------------------------------
   --
   function Script_Hash
     (K : Unbounded_String)
      return Integer is
   begin
      return String_Hash (To_String (K));
   end Script_Hash;

   ---------------------------------------------------------------------------
   -- Creates a new compiler for GSL scripts
   function Create_Compiler return Compiler is

      Comp : Compiler;
   begin
      Comp := new Compiler_Record;
      Comp.Scripts := Script_Hashed_Mappings.Create;
      return Comp;
   end Create_Compiler;

   ---------------------------------------------------------------------------
   -- destroys a compiler
   procedure Destroy_Compiler
     (Comp : Compiler) is
   begin
      null;
   end Destroy_Compiler;

   ---------------------------------------------------------------------------
   -- builds an execution stack for the Gsl interpreter
   -- first looks in the cache (Hash_Map) for the syntax tree
   -- if necessary the Gsl parser is used
   function Get_Execution_Stack
     (Comp : Compiler;
      Name : String)
      return Execution_Stacks.Stack is

      Script : Gsl_Script; 
      Stack  : Execution_Stacks.Stack;
   begin
      if Script_Hashed_Mappings.Is_Bound (Comp.Scripts, 
        To_Unbounded_String(Name)) then
         -- script was already parsed
         -- syntax tree is in the cache
         Script := Script_Hashed_Mappings.Fetch (Comp.Scripts,
           To_Unbounded_String(Name)); 
         return Get_Execution_Stack (Comp, Script.Syntax_Tree);
      else
         Script := new Gsl_Script_Record (Name'Length);
         Script.Name := Name;
 
        -- insert script in hash map
         Script_Hashed_Mappings.Bind (Comp.Scripts,
           To_Unbounded_String(Name), Script);

         -- use the gsl parser to generate a syntax tree
         --Giant.Scanner.IO.Open_Input (Name & ".gsl");
         Giant.Scanner.IO.Open_Input (Name);
         Giant.Parser.yyparse;
         Script.Syntax_Tree := Giant.Parser.Get_Syntax_Tree;
         Giant.Scanner.IO.Close_Input;
         return Get_Execution_Stack (Comp, Script.Syntax_Tree);
      end if;
   end Get_Execution_Stack;

   ---------------------------------------------------------------------------
   -- creates and builds a new execution stack for the Gsl interpreter
   -- by a recursive traversing of the syntax tree
   -- this function is called directly by the Gsl interpreter or by the
   -- compiler function Get_Execution_Stack (Comp : Compiler; Name : String);
   function Get_Execution_Stack
     (Comp : Compiler;
      Node : Syntax_Node)
      return Execution_Stacks.Stack is

      Stack : Execution_Stacks.Stack;
   begin
      Stack := Execution_Stacks.Create;
      Push_Syntax_Node (Node, Stack);
      return Stack;
   end Get_Execution_Stack;

   ---------------------------------------------------------------------------
   -- push a syntax node on top of the execution stack
   procedure Push_Syntax_Node
     (Node  :        Syntax_Node;
      Stack : in out Execution_Stacks.Stack) is
 
      Size       : Natural := 1;
      Local_Node : Syntax_Node;
   begin
      if Node /= Null_Node then
         -- work with a copy
         Local_Node := Copy_Node (Node);
         if Get_Node_Type (Node) = Sequence or 
            Get_Node_Type (Node) = List then
            -- Sequence or List needs a recursive traversation
            -- push all elements using Push_Sequence
            Execution_Stacks.Push (Stack, Local_Node);
            if Get_Child1 (Node) = Null_Node then
               -- empty sequence or list, set size to 0
               Set_Size (Local_Node, 0);
            else
               -- push all elements of the sequence
               Push_Sequence (Node, Stack, Size);
               -- set the size of the sequence
               Set_Size (Local_Node, Size);
            end if;

         elsif Get_Node_Type (Node) = Script_Activation then
            -- Script_Activation, needs to push Child1 (Script_Reference)
            -- and Child2 (parameter)
            Execution_Stacks.Push (Stack, Local_Node);
            -- push the list (parameter)
            Push_Syntax_Node (Get_Child2 (Node), Stack);
            -- push the expression (Script_Reference)
            Push_Syntax_Node (Get_Child1 (Node), Stack);

         else
            -- default for all other nodes (only push the node)
            Execution_Stacks.Push (Stack, Local_Node);
         end if;
      end if;
   end Push_Syntax_Node;

   ---------------------------------------------------------------------------
   -- push a sequence or list on top of the execution stack
   procedure Push_Sequence
     (Node  :        Syntax_Node;
      Stack : in out Execution_Stacks.Stack;
      Size  : in out Natural) is 

   begin
      if Get_Child2 (Node) = Null_Node then
         -- end of a sequence
         Push_Syntax_Node (Get_Child1 (Node), Stack);
      else
         -- recursive
         Size := Size + 1;
         Push_Sequence (Get_Child2 (Node) , Stack, Size);
         Push_Syntax_Node (Get_Child1 (Node), Stack);
      end if;
   end Push_Sequence;

end Giant.Gsl.Compilers;
